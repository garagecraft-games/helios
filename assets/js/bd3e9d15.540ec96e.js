"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[7724],{28453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>t});var r=n(96540);const d={},o=r.createContext(d);function i(e){const s=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function t(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:i(e.components),r.createElement(o.Provider,{value:s},e.children)}},72331:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"helios/pages/todo","title":"todo","description":"Member helios::~Application  ()=default","source":"@site/docs/helios/pages/todo.md","sourceDirName":"helios/pages","slug":"/helios/pages/todo","permalink":"/docs/helios/pages/todo","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"current","frontMatter":{"slug":"/helios/pages/todo","custom_edit_url":null,"toc_max_heading_level":4,"keywords":["doxygen","reference","page"]},"sidebar":"doxygenSidebar","previous":{"title":"Macro Definitions","permalink":"/docs/helios/indices/files/defines"}}');var d=n(74848),o=n(28453);const i={slug:"/helios/pages/todo",custom_edit_url:null,toc_max_heading_level:4,keywords:["doxygen","reference","page"]},t="Todo List",a={},l=[];function c(e){const s={a:"a",dd:"dd",div:"div",dl:"dl",dt:"dt",h1:"h1",header:"header",hr:"hr",p:"p",...(0,o.R)(),...e.components};return(0,d.jsxs)(s.div,{className:"doxyPage",children:["\n",(0,d.jsx)(s.header,{children:(0,d.jsx)(s.h1,{id:"todo-list",children:"Todo List"})}),"\n",(0,d.jsxs)(s.dl,{className:"doxyVariableList",children:["\n",(0,d.jsxs)(s.dt,{children:["Member ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/app/application/#aec579824c0704542d3f7d6c4f47851a1",children:"helios::app::Application::~Application"}),"  ()=default"]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000003"}),"free resource allocations from renderingDevice, window and InputManager"]})}),"\n",(0,d.jsxs)(s.dt,{children:["Member ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/engine/framepacer/#a32ee1e380de39424a708a979a982d19d",children:"helios::engine::FramePacer::sync"}),"  ()"]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000004"}),"Implement hybrid spinning for the last millisecond of the wait time to improve timing precision and mitigate OS scheduler wake-up latency."]})}),"\n",(0,d.jsxs)(s.dt,{children:["Class ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/engine/game/gameobject",children:"helios::engine::game::GameObject"})]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000005"}),"Implement observer pattern or weak_ptr to detect SceneNode destruction and invalidate the transform pointer to prevent dangling pointer issues."]})}),"\n",(0,d.jsxs)(s.dt,{children:["Member ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/engine/game/gameobject/#a2453e79f258cf580d9ef54b7f87e60cc",children:"helios::engine::game::GameObject::transform_"})]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000006"}),"Implement notification mechanism to invalidate this pointer when the SceneNode is destroyed. Consider using observer pattern or std::weak_ptr to safely detect SceneNode destruction."]})}),"\n",(0,d.jsxs)(s.dt,{children:["Class ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/engine/game/inputsnapshot",children:"helios::engine::game::InputSnapshot"})]}),"\n",(0,d.jsxs)(s.dd,{children:["\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000007"}),"Extend to support multiple gamepads, keyboard, and mouse input."]}),"\n",(0,d.jsx)(s.p,{children:"Add timestamp to enable precise replay and network synchronization."}),"\n"]}),"\n",(0,d.jsxs)(s.dt,{children:["Class ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/event/event",children:"helios::event::Event"})]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000008"}),"can we reset the value for Guids in between frames, if events are guaranteed to be dispatched and processed in between frames?"]})}),"\n",(0,d.jsxs)(s.dt,{children:["Class ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/ext/glfw/window/glfwwindow",children:"helios::ext::glfw::window::GLFWWindow"})]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000001"}),"add glfwSetWindowRefreshCallback"]})}),"\n",(0,d.jsxs)(s.dt,{children:["Member ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/ext/opengl/rendering/opengldevice/#aa97dd0a5a8fb57989616b7fac5139f8b",children:"helios::ext::opengl::rendering::OpenGLDevice::init"}),"  () override"]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000002"}),"Provide abstraction for glfwGetProcAddress."]})}),"\n",(0,d.jsxs)(s.dt,{children:["Member ",(0,d.jsx)(s.a,{href:"/docs/helios/structs/helios/math/mat4/#a11484773381edf083309360d6c940d3f",children:"helios::math::mat4< T >::same"}),"  (const mat4< T > &rgt) const"]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000009"}),"account for abs (values close to zero) and rel (larger values), move EPSILON to global constant"]})}),"\n",(0,d.jsxs)(s.dt,{children:["Member ",(0,d.jsx)(s.a,{href:"/docs/helios/structs/helios/math/vec2/#a14a40e171d65f8df56deab0b80a6c800",children:"helios::math::vec2< T >::same"}),"  (const vec2< T > &rgt, T epsilon=0.0001) const"]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000010"}),"account for abs (values close to zero) and rel (larger values), move epsilon to global constant?"]})}),"\n",(0,d.jsxs)(s.dt,{children:["Member ",(0,d.jsx)(s.a,{href:"/docs/helios/structs/helios/math/vec3/#a38d076eec3ebd34f4353d99e3f58ad1e",children:"helios::math::vec3< T >::same"}),"  (const vec3< T > &rgt, T epsilon=0.0001) const"]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000011"}),"account for abs (values close to zero) and rel (larger values), move epsilon to global constant?"]})}),"\n",(0,d.jsxs)(s.dt,{children:["Member ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/model/mesh/#abd79cc39a499bd1b368afd4dd534b00b",children:"helios::rendering::model::Mesh::init"}),"  ()=0"]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000012"})," std::shared_ptr<const std::vector<Texture>> textures_;"]})}),"\n",(0,d.jsxs)(s.dt,{children:["Member ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/renderpassfactory/#a18d1346e8e3c78358ccb1872da3125a3",children:"helios::rendering::RenderPassFactory::makeRenderCommand"}),"  (const ",(0,d.jsx)(s.a,{href:"/docs/helios/structs/helios/scene/snapshotitem",children:"helios::scene::SnapshotItem"})," &snapshotItem) const noexcept"]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000013"}),"future versions might want to use a FactoryMethod in ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/rendercommand",children:"RenderCommand"})," that takes a SnapshotItem and creates a ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/rendercommand",children:"RenderCommand"})," from it (e.g. `RenderCommand::fromSnapshotItem()`); or a Factory `RenderCommandBuilder()` with fluent configuration `.withShader().withMesh().build();`"]})}),"\n",(0,d.jsxs)(s.dt,{children:["Member ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/renderqueue/#ace107c45024c29efc237107e3307c2ab",children:"helios::rendering::RenderQueue::add"}),"  (std::unique_ptr< const helios::rendering::RenderCommand > renderCommand)"]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000014"}),"prevent adding renderables while rendering"]})}),"\n",(0,d.jsxs)(s.dt,{children:["Class ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/rendertarget",children:"helios::rendering::RenderTarget"})]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000015"}),"This implementation currently represents only the **default framebuffer**. Future extensions should allow it to represent arbitrary framebuffer objects (FBOs), using indices."]})}),"\n",(0,d.jsxs)(s.dt,{children:["Member ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/rendertarget/#a65cfc3bea57ac3b5eb398c85754dc049",children:"helios::rendering::RenderTarget::setSize"}),"  (unsigned int width, unsigned int height) noexcept"]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000017"}),"A LayoutManager could be introduced to manage the arrangement of multiple viewports."]})}),"\n",(0,d.jsxs)(s.dt,{children:["Class ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/shader/uniformvaluemap",children:"helios::rendering::shader::UniformValueMap"})]}),"\n",(0,d.jsxs)(s.dd,{children:["\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000018"}),"UniformMap must allow only one index for all data structures, i.e. if map_[semantics] contains a mat4f, other types should not be allowed for the same semantics."]}),"\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000019"}),"UniformValueMaps should be scoped, e.g. per frame (world matrix, projection, view...), per material (colors, emissive...), per object (world matrix...), which allows for better handling of assigning uniforms: per-frame values change once per frame, while per-object values change per object."]}),"\n"]}),"\n",(0,d.jsxs)(s.dt,{children:["Member ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/viewport/#a9c8ed040c0e35728770ddd462860c5bc",children:"helios::rendering::Viewport::setRenderTarget"}),"  (const ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/rendertarget",children:"helios::rendering::RenderTarget"})," *renderTarget, ",(0,d.jsx)(s.a,{href:"/docs/helios/structs/helios/rendering/viewportkey",children:"ViewportKey"})," key) noexcept"]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000020"}),"The ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/viewport",children:"Viewport"})," should observe the ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/rendertarget",children:"RenderTarget"})," for state changes (e.g., resize)."]})}),"\n",(0,d.jsxs)(s.dt,{children:["Class ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/scene/frustumcullingstrategy",children:"helios::scene::FrustumCullingStrategy"})]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000021"}),'The returned list should be considered "as is" for now: Each entry in the list is a single renderable entity to consider. Its child nodes (i.e. the sub tree for which this node is the root) should _not_ be automatically considered for rendering. Later iterations should probably use an individual struct that provides a hint whether for a given node a whole subtree should be considered, saving time for culling and memory when constructing the list.']})}),"\n",(0,d.jsxs)(s.dt,{children:["Member ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/scene/scene/#ab3ad742392c2a2b159cf8927ee6cf375",children:"helios::scene::Scene::createSnapshot"}),"  (const std::shared_ptr< const rendering::Viewport > &viewport) const"]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000023"}),"This should be refactored into a factory to prevent domain leakage between ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/scene/scene",children:"Scene"})," and Rendering."]})}),"\n",(0,d.jsxs)(s.dt,{children:["Member ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/scene/scenenode/#a316494fedf68d4ca53cd4453885e0b07",children:"helios::scene::SceneNode::SceneNode"}),"  () noexcept"]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000024"}),"explicitly implement move (assignment) constructor if required, since we have deleted the copy constructors"]})}),"\n",(0,d.jsxs)(s.dt,{children:["Struct ",(0,d.jsx)(s.a,{href:"/docs/helios/structs/helios/scene/snapshotitem",children:"helios::scene::SnapshotItem"})]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000025"}),"we're intentionally preferring stability over performance by using weak_ptr instead of raw pointers. This leaves room for (performance) improvements in later iterations. The Renderable as a weak pointer can later on be further implemented into a pure DTO, storing only scalar values that get send directly to the underlying rendering backend (e.g. vaos, vbos etc.)."]})}),"\n",(0,d.jsxs)(s.dt,{children:["Class ",(0,d.jsx)(s.a,{href:"/docs/helios/classes/helios/scene/transform",children:"helios::scene::Transform"})]}),"\n",(0,d.jsx)(s.dd,{children:(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.a,{id:"_todo000026"}),"use quaternions for rotation"]})}),"\n"]}),"\n",(0,d.jsx)(s.hr,{}),"\n",(0,d.jsxs)(s.p,{className:"doxyGeneratedBy",children:["Generated via ",(0,d.jsx)(s.a,{href:"https://xpack.github.io/doxygen2docusaurus",children:"doxygen2docusaurus"})," 2.0.0 by ",(0,d.jsx)(s.a,{href:"https://www.doxygen.nl",children:"Doxygen"})," 1.15.0."]}),"\n"]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,d.jsx)(s,{...e,children:(0,d.jsx)(c,{...e})}):c(e)}}}]);