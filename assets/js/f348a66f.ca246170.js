"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[39567],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var r=t(96540);const a={},i=r.createContext(a);function s(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:n},e.children)}},45324:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"examples/gamepad-input","title":"Game Controller Input","description":"Tutorial: Handling gamepad/controller input in helios - buttons, analog sticks, and triggers.","source":"@site/docs/examples/gamepad-input.md","sourceDirName":"examples","slug":"/examples/gamepad-input","permalink":"/docs/examples/gamepad-input","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/examples/gamepad-input.md","tags":[{"inline":true,"label":"examples","permalink":"/docs/tags/examples"},{"inline":true,"label":"input","permalink":"/docs/tags/input"},{"inline":true,"label":"tutorial","permalink":"/docs/tags/tutorial"}],"version":"current","frontMatter":{"title":"Game Controller Input","description":"Tutorial: Handling gamepad/controller input in helios - buttons, analog sticks, and triggers.","slug":"/examples/gamepad-input","sidebar_label":"Gamepad Input","tags":["examples","input","tutorial"],"keywords":["helios","gamepad","controller","input","tutorial"]},"sidebar":"tutorialSidebar","previous":{"title":"Simple Cube","permalink":"/docs/examples/simple-cube"},"next":{"title":"Spaceship Control","permalink":"/docs/examples/spaceship-control"}}');var a=t(74848),i=t(28453);const s={title:"Game Controller Input",description:"Tutorial: Handling gamepad/controller input in helios - buttons, analog sticks, and triggers.",slug:"/examples/gamepad-input",sidebar_label:"Gamepad Input",tags:["examples","input","tutorial"],keywords:["helios","gamepad","controller","input","tutorial"]},l="Game Controller Input - Tutorial",o={},d=[{value:"What You&#39;ll Learn",id:"what-youll-learn",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Project Structure",id:"project-structure",level:2},{value:"Step-by-Step Tutorial",id:"step-by-step-tutorial",level:2},{value:"1. Application and Input Manager Setup",id:"1-application-and-input-manager-setup",level:3},{value:"2. Registering the Gamepad",id:"2-registering-the-gamepad",level:3},{value:"3. Scene Setup for Visualization",id:"3-scene-setup-for-visualization",level:3},{value:"4. The Main Render Loop",id:"4-the-main-render-loop",level:3},{value:"5. Reading Input and Applying Updates",id:"5-reading-input-and-applying-updates",level:3},{value:"Building and Running",id:"building-and-running",level:2},{value:"Expected Output",id:"expected-output",level:2},{value:"Key helios Concepts",id:"key-helios-concepts",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Controller Not Detected",id:"controller-not-detected",level:3},{value:"No Visual Feedback",id:"no-visual-feedback",level:3},{value:"License",id:"license",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"game-controller-input---tutorial",children:"Game Controller Input - Tutorial"})}),"\n",(0,a.jsx)(n.p,{children:"This example demonstrates how to handle real-time gamepad/controller input using the helios framework. It covers polling device state, reading button and analog axis values, and using that input to drive visual feedback in a scene."}),"\n",(0,a.jsx)(n.h2,{id:"what-youll-learn",children:"What You'll Learn"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Setting up the helios ",(0,a.jsx)(n.code,{children:"InputManager"})," for gamepads"]}),"\n",(0,a.jsx)(n.li,{children:"Registering and polling controller devices"}),"\n",(0,a.jsx)(n.li,{children:"Reading button states (pressed/released)"}),"\n",(0,a.jsx)(n.li,{children:"Reading analog stick and trigger values"}),"\n",(0,a.jsx)(n.li,{children:"Structuring a scene to visualize input"}),"\n",(0,a.jsx)(n.li,{children:"Updating scene node transforms and materials based on input"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"helios framework properly built and installed"}),"\n",(0,a.jsx)(n.li,{children:"A compatible USB or Bluetooth game controller (e.g., Xbox, PlayStation)"}),"\n",(0,a.jsx)(n.li,{children:"Basic understanding of C++ and the helios scene graph"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"project-structure",children:"Project Structure"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"game_controller_input/\n\u251c\u2500\u2500 main.cpp           # Main application code\n\u251c\u2500\u2500 resources/\n\u2502   \u251c\u2500\u2500 simple_vertex_shader.vert\n\u2502   \u2514\u2500\u2500 simple_fragment_shader.frag\n\u2514\u2500\u2500 README.md         # This file\n"})}),"\n",(0,a.jsx)(n.h2,{id:"step-by-step-tutorial",children:"Step-by-Step Tutorial"}),"\n",(0,a.jsx)(n.h3,{id:"1-application-and-input-manager-setup",children:"1. Application and Input Manager Setup"}),"\n",(0,a.jsxs)(n.p,{children:["We start by creating an application and getting a reference to its ",(0,a.jsx)(n.code,{children:"InputManager"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'// From main()\nconst auto app = GLFWFactory::makeOpenGLApp(\n    "helios - Game Controller Input Demo"\n);\nauto win = dynamic_cast<GLFWWindow*>(app->current());\n\nInputManager& inputManager = app->inputManager();\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-registering-the-gamepad",children:"2. Registering the Gamepad"}),"\n",(0,a.jsxs)(n.p,{children:["Before we can receive input, we must tell the ",(0,a.jsx)(n.code,{children:"InputManager"})," which controller(s) to listen to."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'// From main()\nunsigned int mask = inputManager.registerGamepads(Gamepad::ONE);\nassert(mask == 1 && "unexpected return value for mask");\n'})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Gamepad::ONE"})," specifies that we want to use the first connected controller."]}),"\n",(0,a.jsxs)(n.li,{children:["You can register multiple controllers using a bitmask (e.g., ",(0,a.jsx)(n.code,{children:"Gamepad::ONE | Gamepad::TWO"}),")."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"3-scene-setup-for-visualization",children:"3. Scene Setup for Visualization"}),"\n",(0,a.jsxs)(n.p,{children:["We create a scene with several simple shapes (circles, rectangles) that will represent the controller's buttons, sticks, and triggers. Each shape is a ",(0,a.jsx)(n.code,{children:"SceneNode"})," with a ",(0,a.jsx)(n.code,{children:"Renderable"})," component."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"// From main()\n\n// Create a shared shader and material properties\nauto shader = std::make_shared<OpenGLShader>(...);\nauto buttonMaterialPropsOverride = MaterialPropertiesOverride(...);\n\n// Create a renderable for a button (e.g., a circle)\nauto buttonRenderableA = std::make_shared<Renderable>(\n    circlePrototype, buttonMaterialPropsOverride\n);\n\n// Add the renderable to a scene node\nconst auto buttonGroupNode_ptr = scene.addNode(std::make_unique<SceneNode>());\nconst auto buttonA_ptr = buttonGroupNode_ptr->addNode(\n    std::make_unique<SceneNode>(buttonRenderableA)\n);\n"})}),"\n",(0,a.jsx)(n.p,{children:"This process is repeated for all visual elements (B, X, Y buttons, sticks, etc.)."}),"\n",(0,a.jsx)(n.h3,{id:"4-the-main-render-loop",children:"4. The Main Render Loop"}),"\n",(0,a.jsxs)(n.p,{children:["The core logic resides in the ",(0,a.jsx)(n.code,{children:"while"})," loop, which runs every frame."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"// From main()\nwhile (!win->shouldClose()) {\n    // 1. Process window events\n    app->eventManager().dispatchAll();\n\n    // 2. Poll for new input\n    inputManager.poll(0.0f);\n\n    // 3. Get the state of our registered gamepad\n    const GamepadState& gamepadState = inputManager.gamepadState(Gamepad::ONE);\n\n    // 4. Update visuals based on the new state\n    updateButton(*buttonA_ptr, gamepadState.buttonA(), ...);\n    // ... update other elements ...\n\n    // 5. Render the scene\n    auto snapshot = scene.createSnapshot(...);\n    auto renderPass = RenderPassFactory::getInstance().buildRenderPass(snapshot);\n    app->renderingDevice().render(renderPass);\n\n    // 6. Swap buffers\n    win->swapBuffers();\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Loop Breakdown:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Event Processing"}),": Handles window events like closing."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Input Polling"}),": ",(0,a.jsx)(n.code,{children:"inputManager.poll()"})," updates the internal state of all registered devices. This is a crucial step."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Get State"}),": ",(0,a.jsx)(n.code,{children:"inputManager.gamepadState()"})," provides a snapshot of the controller's current state for that frame."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Update Logic"}),": We use the ",(0,a.jsx)(n.code,{children:"gamepadState"})," object to modify our scene."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Rendering"}),": The updated scene is drawn to the screen."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"5-reading-input-and-applying-updates",children:"5. Reading Input and Applying Updates"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"GamepadState"})," object provides simple accessors for all inputs."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Reading Buttons:"}),"\nThe ",(0,a.jsx)(n.code,{children:"buttonA()"})," method returns ",(0,a.jsx)(n.code,{children:"true"})," if the 'A' button is currently held down. We pass this boolean to a helper function."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"// In the main loop\nupdateButton(*buttonA_ptr, gamepadState.buttonA(), buttonMaterialPropsOverride);\nupdateButton(*buttonB_ptr, gamepadState.buttonB(), buttonMaterialPropsOverride);\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsxs)(n.strong,{children:["The ",(0,a.jsx)(n.code,{children:"updateButton"})," Helper:"]}),"\nThis function scales the node and changes its opacity to give visual feedback."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"void updateButton(\n    helios::scene::SceneNode& button,\n    const bool pressed,\n    helios::rendering::model::config::MaterialPropertiesOverride& originalOverride\n) {\n    // Scale up when pressed\n    button.setScale(helios::math::vec3f(SCALING_FACTOR * (pressed ? 1.2f : 1.0f)));\n    \n    // Make it opaque when pressed, semi-transparent otherwise\n    if (button.renderable()->hasMaterialOverride()) {\n        // ... logic to change material alpha ...\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Reading Analog Axes:"}),"\nThe ",(0,a.jsx)(n.code,{children:"leftX()"}),", ",(0,a.jsx)(n.code,{children:"leftY()"}),", and ",(0,a.jsx)(n.code,{children:"triggerLeft()"})," methods return a ",(0,a.jsx)(n.code,{children:"float"})," value, typically between ",(0,a.jsx)(n.code,{children:"-1.0"})," and ",(0,a.jsx)(n.code,{children:"1.0"})," for sticks and ",(0,a.jsx)(n.code,{children:"0.0"})," to ",(0,a.jsx)(n.code,{children:"1.0"})," for triggers."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"// In the main loop\n\n// Get stick and trigger values\nconst float leftTrigger = gamepadState.triggerLeft();\nconst float axisLeftX  = gamepadState.leftX();\n\n// Use values to transform scene nodes\nstickAxisLeft_ptr->setScale(helios::math::vec3f(gamepadState.left() * 0.5f));\ntriggerLeftNode_ptr->setScale(helios::math::vec3f(triggerBaseScale[0] * leftTrigger, ...));\n"})}),"\n",(0,a.jsx)(n.h2,{id:"building-and-running",children:"Building and Running"}),"\n",(0,a.jsx)(n.p,{children:"From the project root directory:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Configure the build\ncmake -S . -B build -DCMAKE_BUILD_TYPE=Release\n\n# Build the project\ncmake --build build --config Release\n\n# Run the example (Windows)\n.\\build\\examples\\game_controller_input\\Release\\main.exe\n"})}),"\n",(0,a.jsx)(n.h2,{id:"expected-output",children:"Expected Output"}),"\n",(0,a.jsxs)(n.p,{children:["A window will appear displaying a layout of shapes. When you press buttons, move the sticks, or pull the triggers on your connected controller, the corresponding shapes will change size and color in real-time. Press ",(0,a.jsx)(n.code,{children:"ESC"})," to exit."]}),"\n",(0,a.jsx)(n.h2,{id:"key-helios-concepts",children:"Key helios Concepts"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"InputManager"})}),": The central hub for all input devices."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"registerGamepads()"})}),": Tells the ",(0,a.jsx)(n.code,{children:"InputManager"})," which controllers to track."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"poll()"})}),": The function that must be called every frame to capture new input data."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"gamepadState()"})}),": Retrieves a read-only snapshot of a controller's state for the current frame."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:[(0,a.jsx)(n.code,{children:"GamepadState"})," Object"]}),": Provides simple accessors like ",(0,a.jsx)(n.code,{children:"buttonA()"}),", ",(0,a.jsx)(n.code,{children:"leftX()"}),", ",(0,a.jsx)(n.code,{children:"triggerRight()"})," to get input values."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,a.jsx)(n.h3,{id:"controller-not-detected",children:"Controller Not Detected"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Ensure your controller is properly connected via USB or Bluetooth before starting the application."}),"\n",(0,a.jsx)(n.li,{children:"Verify the controller works in other games or system utilities."}),"\n",(0,a.jsx)(n.li,{children:"Check the console output for any messages from GLFW about controller detection."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"no-visual-feedback",children:"No Visual Feedback"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Confirm that ",(0,a.jsx)(n.code,{children:"inputManager.poll()"})," is being called inside the main loop."]}),"\n",(0,a.jsxs)(n.li,{children:["Make sure you are requesting the correct gamepad index with ",(0,a.jsx)(n.code,{children:"inputManager.gamepadState(Gamepad::ONE)"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"license",children:"License"}),"\n",(0,a.jsx)(n.p,{children:"This example is part of the helios framework and is distributed under the MIT License."})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);