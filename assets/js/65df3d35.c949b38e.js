"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[8559],{28453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>d});var r=i(96540);const s={},a=r.createContext(s);function t(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(a.Provider,{value:n},e.children)}},61596:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"api/overview","title":"helios - API Reference","description":"Introduction","source":"@site/docs/api/overview.md","sourceDirName":"api","slug":"/api/overview","permalink":"/docs/api/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/api/overview.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1}}');var s=i(74848),a=i(28453);const t={sidebar_position:1},d="helios - API Reference",l={},o=[{value:"Introduction",id:"introduction",level:2},{value:"Core Purpose",id:"core-purpose",level:2},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Core Modules",id:"core-modules",level:3},{value:"Extension Modules",id:"extension-modules",level:3},{value:"Core Concepts",id:"core-concepts",level:2},{value:"1. Scene Graph",id:"1-scene-graph",level:3},{value:"2. Rendering Pipeline",id:"2-rendering-pipeline",level:3},{value:"3. Material System",id:"3-material-system",level:3},{value:"4. Input System",id:"4-input-system",level:3},{value:"Quick Start",id:"quick-start",level:2},{value:"Creating a Simple Application",id:"creating-a-simple-application",level:3},{value:"Module Details",id:"module-details",level:2},{value:"Advanced Topics",id:"advanced-topics",level:2},{value:"Custom Rendering Backend",id:"custom-rendering-backend",level:3},{value:"Custom Input Adapter",id:"custom-input-adapter",level:3},{value:"API Documentation",id:"api-documentation",level:2},{value:"Examples",id:"examples",level:2},{value:"License",id:"license",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"helios---api-reference",children:"helios - API Reference"})}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"helios"})," is an ongoing, educational project and strives for providing a foundational and modular technical backbone for game development. Designed with a top-down, prototype-oriented approach, it emphasizes a clear separation of concerns and robust architectural patterns to help with creating maintainable games."]}),"\n",(0,s.jsx)(n.h2,{id:"core-purpose",children:"Core Purpose"}),"\n",(0,s.jsxs)(n.p,{children:["The primary objective of ",(0,s.jsx)(n.code,{children:"helios"})," is to offer a flexible and extensible platform for interactive games. As a prototype, it provides the following systems:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rendering Pipeline:"})," A rendering layer with customizable render passes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Modular Subsystems:"})," Well-defined interfaces for core components such as Scene Management and Rendering."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Modern C++ Practices:"})," Leveraging C++(23) Modules for improved dependency management and compile-time efficiency."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,s.jsx)(n.p,{children:"The framework's architecture follows a component-based philosophy, providing abstract interfaces that decouple high-level scene descriptions from underlying hardware implementations."}),"\n",(0,s.jsx)(n.h3,{id:"core-modules",children:"Core Modules"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"helios\n\u251c\u2500\u2500 rendering          # Rendering pipeline and render commands\n\u2502   \u251c\u2500\u2500 model         # Mesh, Material, and configuration\n\u2502   \u251c\u2500\u2500 shader        # Shader programs and uniform management\n\u2502   \u2514\u2500\u2500 asset         # Geometric shapes and assets\n\u251c\u2500\u2500 scene             # Scene graph, camera, and culling\n\u251c\u2500\u2500 input             # Keyboard, mouse, and gamepad input\n\u251c\u2500\u2500 window            # Window management and events\n\u251c\u2500\u2500 math              # Vectors, matrices, transforms\n\u251c\u2500\u2500 util              # Logging, file I/O, utilities\n\u2514\u2500\u2500 app               # Application lifecycle and event management\n"})}),"\n",(0,s.jsx)(n.h3,{id:"extension-modules",children:"Extension Modules"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"helios.ext\n\u251c\u2500\u2500 glfw              # GLFW-based window and input implementation\n\u2502   \u251c\u2500\u2500 window\n\u2502   \u251c\u2500\u2500 input\n\u2502   \u2514\u2500\u2500 app\n\u2514\u2500\u2500 opengl            # OpenGL rendering backend\n    \u251c\u2500\u2500 rendering\n    \u2514\u2500\u2500 shader\n"})}),"\n",(0,s.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"1-scene-graph",children:"1. Scene Graph"}),"\n",(0,s.jsx)(n.p,{children:"The scene graph organizes objects hierarchically, with automatic transform propagation from parent to child nodes."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Classes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Scene"})," - Root container for all scene objects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"SceneNode"})," - Node in the hierarchy with transform and optional renderable"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Camera"})," - Defines the viewpoint and projection"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{title:"Simplified Example",type:"info",children:(0,s.jsxs)(n.p,{children:["The following code demonstrates scene graph usage. Variables like ",(0,s.jsx)(n.code,{children:"cullingStrategy"}),", ",(0,s.jsx)(n.code,{children:"cubeRenderable"}),", and ",(0,s.jsx)(n.code,{children:"rotationMatrix"})," are assumed to be pre-initialized. See ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://github.com/thorstensuckow/helios/tree/main/examples/simple_cube_rendering",children:"examples/simple_cube_rendering"})})," for complete implementation."]})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"import helios.scene.Scene;\nimport helios.scene.SceneNode;\n\nauto scene = std::make_unique<Scene>(std::move(cullingStrategy));\n\nauto cubeNode = std::make_unique<SceneNode>(std::move(cubeRenderable));\nauto* node = scene->addNode(std::move(cubeNode));\n\nnode->translate(vec3f(0.0f, 2.0f, 0.0f));\nnode->rotate(rotationMatrix);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-rendering-pipeline",children:"2. Rendering Pipeline"}),"\n",(0,s.jsx)(n.p,{children:"The rendering pipeline uses a deferred command pattern with render passes."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Flow:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Scene \u2192 Snapshot \u2192 RenderPass \u2192 RenderQueue \u2192 RenderCommand \u2192 GPU\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Classes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"RenderPrototype"})," - Immutable combination of Mesh + Material"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Renderable"})," - Instance of a RenderPrototype with optional overrides"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"RenderCommand"})," - Low-level GPU command"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"RenderQueue"})," - Collection of commands for a pass"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"RenderPass"})," - Execution unit with frame-specific uniforms"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{title:"Simplified Example",type:"info",children:(0,s.jsxs)(n.p,{children:["Material and mesh creation omitted for brevity. See ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"../examples/simple-cube",children:"Simple Cube Tutorial"})})," for complete shader, material, and mesh setup."]})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"import helios.rendering.RenderPrototype;\nimport helios.rendering.Renderable;\n\n// Create prototype (shared)\nauto prototype = std::make_shared<RenderPrototype>(material, mesh);\n\n// Create instance\nauto renderable = std::make_shared<Renderable>(prototype);\n\n// Optional per-instance material override\nrenderable->materialOverride() = MaterialPropertiesOverride{\n    .baseColor = vec4f(1.0f, 0.0f, 0.0f, 1.0f)\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-material-system",children:"3. Material System"}),"\n",(0,s.jsx)(n.p,{children:"Materials define surface appearance with shaders and properties."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Classes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Material"})," - Shader + default MaterialProperties"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MaterialProperties"})," - Immutable value object (baseColor, roughness, etc.)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MaterialPropertiesOverride"})," - Per-instance overrides"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'import helios.rendering.model.Material;\nimport helios.rendering.model.config.MaterialProperties;\nimport helios.ext.opengl.rendering.shader.OpenGLShader;\nimport helios.util.io.BasicStringFileReader;\n\n// Create shader (example)\nauto fileReader = BasicStringFileReader();\nauto shader = std::make_shared<OpenGLShader>(\n    "./resources/shader.vert",\n    "./resources/shader.frag",\n    fileReader\n);\n\n// Create material properties\nauto materialProps = MaterialProperties(\n    vec4f(1.0f, 0.0f, 1.0f, 1.0f), // Base color (magenta)\n    0.5f                             // Roughness\n);\n\nauto material = std::make_shared<Material>(shader, \n    std::make_shared<MaterialProperties>(materialProps));\n'})}),"\n",(0,s.jsx)(n.h3,{id:"4-input-system",children:"4. Input System"}),"\n",(0,s.jsx)(n.p,{children:"Unified input handling for keyboard, mouse, and gamepad."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Classes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"InputManager"})," - Central input coordinator"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"InputAdapter"})," - Platform-specific input implementation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"GamepadState"})," - Current state of a gamepad"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"import helios.input.InputManager;\nimport helios.input.types.Key;\n\nauto& inputManager = app->inputManager();\ninputManager.poll(deltaTime);\n\nif (inputManager.isKeyPressed(Key::SPACE)) {\n    // Handle space key\n}\n\nconst auto& gamepadState = inputManager.gamepadState(Gamepad::Gamepad1);\nif (gamepadState.buttons.A) {\n    // Handle A button\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,s.jsx)(n.h3,{id:"creating-a-simple-application",children:"Creating a Simple Application"}),"\n",(0,s.jsx)(n.admonition,{title:"Complete Example",type:"note",children:(0,s.jsxs)(n.p,{children:["This is a simplified example showing the basic structure. For a complete, working implementation including shader, material, and mesh creation, see the ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"../examples/simple-cube",children:"Simple Cube Rendering Tutorial"})}),"."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'import helios.ext.glfw.app.GLFWFactory;\nimport helios.scene.Scene;\nimport helios.scene.Camera;\n\nint main() {\n    // 1. Create application\n    auto app = GLFWFactory::makeOpenGLApp("My helios App");\n    auto* window = app->current();\n    \n    // 2. Create scene\n    auto scene = std::make_unique<Scene>(\n        std::make_unique<CullNoneStrategy>()\n    );\n    \n    // 3. Add camera\n    auto camera = std::make_unique<Camera>();\n    scene->addNode(std::move(camera));\n    \n    // 4. Create and add renderable\n    // Note: material and mesh creation omitted - see complete example\n    auto prototype = std::make_shared<RenderPrototype>(material, mesh);\n    auto renderable = std::make_shared<Renderable>(prototype);\n    auto node = std::make_unique<SceneNode>(std::move(renderable));\n    scene->addNode(std::move(node));\n    \n    // 5. Main loop\n    while (!window->shouldClose()) {\n        app->eventManager().dispatchAll();\n        \n        auto snapshot = scene->createSnapshot(*camera);\n        auto renderPass = RenderPassFactory::getInstance()\n            .buildRenderPass(snapshot);\n        \n        app->renderingDevice().render(renderPass);\n        window->swapBuffers();\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"module-details",children:"Module Details"}),"\n",(0,s.jsxs)(n.p,{children:["For detailed information about each module, refer to the ",(0,s.jsx)(n.a,{href:"https://thorstensuckow.github.io/helios/api/html/index.html",children:"Doxygen-generated API documentation"})," or explore the source code in the GitHub repository:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rendering"})," - ",(0,s.jsx)(n.code,{children:"include/helios/rendering/"})," - Rendering system and pipeline"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scene"})," - ",(0,s.jsx)(n.code,{children:"include/helios/scene/"})," - Scene graph and camera"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Input"})," - ",(0,s.jsx)(n.code,{children:"include/helios/input/"})," - Input handling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Math"})," - ",(0,s.jsx)(n.code,{children:"include/helios/math/"})," - Mathematical operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Window"})," - ",(0,s.jsx)(n.code,{children:"include/helios/window/"})," - Window management"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Utilities"})," - ",(0,s.jsx)(n.code,{children:"include/helios/util/"})," - Logging, file I/O"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"advanced-topics",children:"Advanced Topics"}),"\n",(0,s.jsx)(n.h3,{id:"custom-rendering-backend",children:"Custom Rendering Backend"}),"\n",(0,s.jsx)(n.p,{children:"To implement a custom rendering backend:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Implement ",(0,s.jsx)(n.code,{children:"RenderingDevice"})," interface"]}),"\n",(0,s.jsxs)(n.li,{children:["Extend ",(0,s.jsx)(n.code,{children:"Mesh"})," for your platform (e.g., ",(0,s.jsx)(n.code,{children:"VulkanMesh"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["Extend ",(0,s.jsx)(n.code,{children:"Shader"})," for your platform (e.g., ",(0,s.jsx)(n.code,{children:"VulkanShader"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["Create a factory (e.g., ",(0,s.jsx)(n.code,{children:"VulkanFactory"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"custom-input-adapter",children:"Custom Input Adapter"}),"\n",(0,s.jsx)(n.p,{children:"To implement a custom input adapter:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Implement ",(0,s.jsx)(n.code,{children:"InputAdapter"})," interface"]}),"\n",(0,s.jsx)(n.li,{children:"Map platform-specific events to helios types"}),"\n",(0,s.jsxs)(n.li,{children:["Update ",(0,s.jsx)(n.code,{children:"GamepadState"})," on polling"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"api-documentation",children:"API Documentation"}),"\n",(0,s.jsxs)(n.p,{children:["For detailed class-by-class documentation, see the ",(0,s.jsx)(n.a,{href:"./api/html/index.html",children:"Doxygen-generated API reference"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.p,{children:"Check the examples section for complete working examples:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"../examples/simple-cube",children:"Simple Cube Rendering"})})," - Basic rendering tutorial"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Game Controller Input"})," - Input handling demo"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"license",children:"License"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"helios"})," is distributed under the MIT-license."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);