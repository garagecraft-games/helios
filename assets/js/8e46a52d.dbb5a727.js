"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[10772],{28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var i=s(96540);const t={},o=i.createContext(t);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(o.Provider,{value:n},e.children)}},72541:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"core-concepts/conventions","title":"Technical Conventions","description":"Coordinate systems (LHS), matrix storage (column-major), and mathematical foundations used in helios.","source":"@site/docs/core-concepts/conventions.md","sourceDirName":"core-concepts","slug":"/core-concepts/conventions","permalink":"/docs/core-concepts/conventions","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/core-concepts/conventions.md","tags":[{"inline":true,"label":"math","permalink":"/docs/tags/math"},{"inline":true,"label":"architecture","permalink":"/docs/tags/architecture"}],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Technical Conventions","description":"Coordinate systems (LHS), matrix storage (column-major), and mathematical foundations used in helios.","slug":"/core-concepts/conventions","sidebar_label":"Conventions","sidebar_position":2,"tags":["math","architecture"],"keywords":["helios","coordinate system","left-handed","matrix","column-major","conventions"]},"sidebar":"tutorialSidebar","previous":{"title":"Prerequisites","permalink":"/docs/prerequisites"},"next":{"title":"Scene Graph","permalink":"/docs/core-concepts/scene-graph"}}');var t=s(74848),o=s(28453);const r={title:"Technical Conventions",description:"Coordinate systems (LHS), matrix storage (column-major), and mathematical foundations used in helios.",slug:"/core-concepts/conventions",sidebar_label:"Conventions",sidebar_position:2,tags:["math","architecture"],keywords:["helios","coordinate system","left-handed","matrix","column-major","conventions"]},a="helios Technical Conventions",l={},c=[{value:"Coordinate System",id:"coordinate-system",level:2},{value:"Left-Handed System (LHS)",id:"left-handed-system-lhs",level:3},{value:"OpenGL Compatibility",id:"opengl-compatibility",level:3},{value:"Matrix Conventions",id:"matrix-conventions",level:2},{value:"Storage Format: Column-Major Order",id:"storage-format-column-major-order",level:3},{value:"Element Access",id:"element-access",level:3},{value:"Translation Components",id:"translation-components",level:3},{value:"Rotation and Scale Components",id:"rotation-and-scale-components",level:3},{value:"Matrix Multiplication Order",id:"matrix-multiplication-order",level:3},{value:"View Matrix Construction",id:"view-matrix-construction",level:2},{value:"Units of Measurement",id:"units-of-measurement",level:2},{value:"Spatial Units",id:"spatial-units",level:3},{value:"Helper Constants",id:"helper-constants",level:4},{value:"Temporal Units",id:"temporal-units",level:3},{value:"Helper Constants",id:"helper-constants-1",level:4},{value:"Usage Example",id:"usage-example",level:3},{value:"Transform Inheritance",id:"transform-inheritance",level:2},{value:"TransformType Flags",id:"transformtype-flags",level:3},{value:"Usage Example",id:"usage-example-1",level:3},{value:"Matrix Decomposition",id:"matrix-decomposition",level:3},{value:"Related Modules",id:"related-modules",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"helios-technical-conventions",children:"helios Technical Conventions"})}),"\n",(0,t.jsx)(n.p,{children:"This document describes the fundamental technical conventions used throughout the helios engine, including coordinate systems, matrix storage, and related mathematical foundations."}),"\n",(0,t.jsx)(n.h2,{id:"coordinate-system",children:"Coordinate System"}),"\n",(0,t.jsx)(n.h3,{id:"left-handed-system-lhs",children:"Left-Handed System (LHS)"}),"\n",(0,t.jsxs)(n.p,{children:["helios uses a ",(0,t.jsx)(n.strong,{children:"Left-Handed Coordinate System"})," (LHS) as its primary spatial convention:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"+X axis"}),": Points to the right"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"+Y axis"}),": Points upward"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"+Z axis"}),": Points forward (into the screen)"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:'This convention aligns with common game engine practices and provides intuitive "depth" semantics where positive Z values represent objects further away from the viewer.'}),"\n",(0,t.jsx)(n.h3,{id:"opengl-compatibility",children:"OpenGL Compatibility"}),"\n",(0,t.jsxs)(n.p,{children:["While helios internally uses LHS, OpenGL expects a Right-Handed System (RHS) where the camera looks down the ",(0,t.jsx)(n.strong,{children:"-Z axis"}),". The engine handles this conversion transparently:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"CameraSceneNode::worldTransform()"})," computes the View Matrix by inverting the camera's world transform"]}),"\n",(0,t.jsx)(n.li,{children:"The Z-axis is negated during View Matrix construction to convert from LHS to OpenGL's RHS clip space"}),"\n",(0,t.jsx)(n.li,{children:"Near and far plane values remain positive regardless of the camera's orientation"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example:"})," An object at world position ",(0,t.jsx)(n.code,{children:"(0, 0, 5)"})," in helios (5 units in front of the origin) will be correctly rendered when the camera is positioned to view it, with the projection handling the LHS-to-RHS conversion."]}),"\n",(0,t.jsx)(n.h2,{id:"matrix-conventions",children:"Matrix Conventions"}),"\n",(0,t.jsx)(n.h3,{id:"storage-format-column-major-order",children:"Storage Format: Column-Major Order"}),"\n",(0,t.jsxs)(n.p,{children:["All ",(0,t.jsx)(n.code,{children:"mat4"})," matrices in helios are stored in ",(0,t.jsx)(n.strong,{children:"column-major order"}),". This means:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The internal array ",(0,t.jsx)(n.code,{children:"m[16]"})," stores elements column by column"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"m[0..3]"})," = Column 0 (elements at rows 0-3)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"m[4..7]"})," = Column 1 (elements at rows 0-3)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"m[8..11]"})," = Column 2 (elements at rows 0-3)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"m[12..15]"})," = Column 3 (elements at rows 0-3)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"element-access",children:"Element Access"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"operator()(row, col)"})," provides intuitive mathematical notation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Access element at row r, column c\nT value = matrix(r, c);  // Internally: m[r + c * 4]\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Memory layout visualization:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Mathematical notation:     Memory layout (column-major):\n| m(0,0) m(0,1) m(0,2) m(0,3) |     m[0]  m[4]  m[8]  m[12]\n| m(1,0) m(1,1) m(1,2) m(1,3) |     m[1]  m[5]  m[9]  m[13]\n| m(2,0) m(2,1) m(2,2) m(2,3) |     m[2]  m[6]  m[10] m[14]\n| m(3,0) m(3,1) m(3,2) m(3,3) |     m[3]  m[7]  m[11] m[15]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"translation-components",children:"Translation Components"}),"\n",(0,t.jsxs)(n.p,{children:["In a standard 4x4 transformation matrix, the ",(0,t.jsx)(n.strong,{children:"translation vector"})," is stored in ",(0,t.jsx)(n.strong,{children:"column 3"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Extracting translation from a transform matrix\nhelios::math::vec3f translation(\n    matrix(0, 3),  // X translation (m[12])\n    matrix(1, 3),  // Y translation (m[13])\n    matrix(2, 3)   // Z translation (m[14])\n);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"rotation-and-scale-components",children:"Rotation and Scale Components"}),"\n",(0,t.jsx)(n.p,{children:"The upper-left 3x3 submatrix contains rotation and scale:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Extracting basis vectors (columns)\nvec3f xAxis(matrix(0, 0), matrix(1, 0), matrix(2, 0));  // Column 0\nvec3f yAxis(matrix(0, 1), matrix(1, 1), matrix(2, 1));  // Column 1\nvec3f zAxis(matrix(0, 2), matrix(1, 2), matrix(2, 2));  // Column 2\n"})}),"\n",(0,t.jsx)(n.h3,{id:"matrix-multiplication-order",children:"Matrix Multiplication Order"}),"\n",(0,t.jsxs)(n.p,{children:["helios uses ",(0,t.jsx)(n.strong,{children:"post-multiplication"})," (column-vector convention):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Transform a point: result = M * v\nvec4f transformed = matrix * vec4f(point, 1.0f);\n\n// Combining transforms: first A, then B\nmat4f combined = B * A;  // A is applied first, then B\n"})}),"\n",(0,t.jsx)(n.h2,{id:"view-matrix-construction",children:"View Matrix Construction"}),"\n",(0,t.jsxs)(n.p,{children:["The View Matrix is computed as the inverse of the camera's World Transform. Since ",(0,t.jsx)(n.code,{children:"helios"})," uses an orthonormal basis for transforms (Rotation + Translation), the inversion is optimized by transposing the rotation matrix and computing the inverse translation."]}),"\n",(0,t.jsx)(n.p,{children:"Additionally, the Z-axis is negated to convert from the engine's Left-Handed System (LHS) to OpenGL's Right-Handed System (RHS)."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// In CameraSceneNode::onWorldTransformUpdate()\nconst auto wt = SceneNode::cachedWorldTransform();\n\n// Extract basis vectors and position\nconst auto x = helios::math::vec3f{wt(0, 0), wt(1, 0), wt(2, 0)};\nconst auto y = helios::math::vec3f{wt(0, 1), wt(1, 1), wt(2, 1)};\nconst auto z = helios::math::vec3f{wt(0, 2), wt(1, 2), wt(2, 2)};\nconst auto eye = helios::math::vec3f{wt(0, 3), wt(1, 3), wt(2, 3)};\n\n// Compute view matrix: inverse of world transform with Z-negation for OpenGL RHS\n// Rotation is transposed (inverse of orthonormal matrix)\n// Translation is: -dot(axis, eye)\nauto viewMatrix = helios::math::mat4f{\n    x[0],          y[0],          -z[0],        0.0f,\n    x[1],          y[1],          -z[1],        0.0f,\n    x[2],          y[2],          -z[2],        0.0f,\n    -dot(x, eye), -dot(y, eye),    dot(z, eye), 1.0f\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"units-of-measurement",children:"Units of Measurement"}),"\n",(0,t.jsx)(n.p,{children:"helios enforces a strict unit convention to ensure consistency across physics, rendering, and game logic."}),"\n",(0,t.jsx)(n.h3,{id:"spatial-units",children:"Spatial Units"}),"\n",(0,t.jsxs)(n.p,{children:["The standard unit of length in helios is the ",(0,t.jsx)(n.strong,{children:"Meter"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"1.0 Helios Unit = 1.0 Meter"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["All spatial coordinates, distances, and sizes in the engine (e.g., ",(0,t.jsx)(n.code,{children:"transform.position"}),", ",(0,t.jsx)(n.code,{children:"mesh.vertices"}),") are expressed in meters."]}),"\n",(0,t.jsx)(n.h4,{id:"helper-constants",children:"Helper Constants"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"helios::core::units"})," module provides constants and conversion helpers:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"helios::core::units::METERS"})," (1.0)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"helios::core::units::CENTIMETERS"})," (0.01)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"temporal-units",children:"Temporal Units"}),"\n",(0,t.jsxs)(n.p,{children:["The standard unit of time in helios is the ",(0,t.jsx)(n.strong,{children:"Second"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"1.0 Helios Time Unit = 1.0 Second"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["All durations, timestamps, and delta times (e.g., ",(0,t.jsx)(n.code,{children:"deltaTime"}),", ",(0,t.jsx)(n.code,{children:"animation.duration"}),") are expressed in seconds."]}),"\n",(0,t.jsx)(n.h4,{id:"helper-constants-1",children:"Helper Constants"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"helios::core::units::SECONDS"})," (1.0)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"helios::core::units::MILLISECONDS"})," (0.001)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"usage-example",children:"Usage Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"import helios.core.units;\n\nusing namespace helios::core::units;\n\n// Define a distance of 50 centimeters\nfloat distance = fromCm(50.0f); // Returns 0.5f (meters)\n\n// Define a duration of 100 milliseconds\nfloat duration = fromMs(100.0f); // Returns 0.1f (seconds)\n\n// Generic conversion\nfloat val = from(100.0f, Unit::Centimeter); // Returns 1.0f\n"})}),"\n",(0,t.jsx)(n.h2,{id:"transform-inheritance",children:"Transform Inheritance"}),"\n",(0,t.jsxs)(n.p,{children:["Scene graph nodes can selectively inherit transform components from their parent using ",(0,t.jsx)(n.code,{children:"helios::math::TransformType"}),". This enables flexible hierarchical behaviors without full transform coupling."]}),"\n",(0,t.jsx)(n.h3,{id:"transformtype-flags",children:"TransformType Flags"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"TransformType"})," enum provides bitmask flags for selective inheritance:"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Flag"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Translation"})}),(0,t.jsx)(n.td,{children:"Inherit only the parent's position offset"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Rotation"})}),(0,t.jsx)(n.td,{children:"Inherit only the parent's orientation"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Scale"})}),(0,t.jsx)(n.td,{children:"Inherit only the parent's scale factors"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"All"})}),(0,t.jsx)(n.td,{children:"Inherit all components (default behavior)"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"usage-example-1",children:"Usage Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"import helios.math.transform;\n\nusing namespace helios::math;\n\n// Camera follows spaceship position but maintains independent orientation\ncameraNode->setInheritance(TransformType::Translation);\n\n// Combine multiple flags\nnode->setInheritance(TransformType::Translation | TransformType::Rotation);\n\n// Full inheritance (default)\nchildNode->setInheritance(TransformType::All);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"matrix-decomposition",children:"Matrix Decomposition"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"mat4::decompose()"})," member function extracts specific transform components from a matrix:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"import helios.math.types;\nimport helios.math.transform;\n\nmat4f fullTransform = /* scaled, rotated, translated */;\n\n// Extract only translation\nmat4f translationOnly = fullTransform.decompose(TransformType::Translation);\n\n// Extract rotation without scale\nmat4f rotationOnly = fullTransform.decompose(TransformType::Rotation);\n\n// Transpose a matrix (useful for inverting orthonormal rotation matrices)\nmat4f transposed = rotationMatrix.transpose();\n"})}),"\n",(0,t.jsx)(n.h2,{id:"related-modules",children:"Related Modules"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"helios.core.units"})," \u2014 Unit conversion and constants"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"helios.math.types"})," \u2014 Core vector and matrix types (",(0,t.jsx)(n.code,{children:"vec3f"}),", ",(0,t.jsx)(n.code,{children:"mat4f"}),") with ",(0,t.jsx)(n.code,{children:"decompose()"})," and ",(0,t.jsx)(n.code,{children:"transpose()"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"helios.math.utils"})," \u2014 Mathematical utility functions (",(0,t.jsx)(n.code,{children:"perspective"}),", ",(0,t.jsx)(n.code,{children:"radians"}),", ",(0,t.jsx)(n.code,{children:"degrees"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"helios.math.transform"})," \u2014 Transform utilities including ",(0,t.jsx)(n.code,{children:"TransformType"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"helios.core.Transform"})," \u2014 Encapsulates translation, rotation, and scale"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"helios.scene.Camera"})," \u2014 Projection matrix management"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"helios.scene.CameraSceneNode"})," \u2014 View matrix computation and scene graph integration"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);