"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[90538],{16730:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"examples/simple-cube","title":"Simple Cube Rendering","description":"Tutorial: Rendering a 3D cube with helios - shaders, materials, meshes, and render loop.","source":"@site/docs/examples/simple-cube.md","sourceDirName":"examples","slug":"/examples/simple-cube","permalink":"/docs/examples/simple-cube","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/examples/simple-cube.md","tags":[{"inline":true,"label":"examples","permalink":"/docs/tags/examples"},{"inline":true,"label":"rendering","permalink":"/docs/tags/rendering"},{"inline":true,"label":"tutorial","permalink":"/docs/tags/tutorial"}],"version":"current","frontMatter":{"title":"Simple Cube Rendering","description":"Tutorial: Rendering a 3D cube with helios - shaders, materials, meshes, and render loop.","slug":"/examples/simple-cube","sidebar_label":"Simple Cube","tags":["examples","rendering","tutorial"],"keywords":["helios","3D rendering","OpenGL","cube","tutorial"]},"sidebar":"tutorialSidebar","previous":{"title":"Overview","permalink":"/docs/examples"},"next":{"title":"Gamepad Input","permalink":"/docs/examples/gamepad-input"}}');var s=r(74848),a=r(28453);const t={title:"Simple Cube Rendering",description:"Tutorial: Rendering a 3D cube with helios - shaders, materials, meshes, and render loop.",slug:"/examples/simple-cube",sidebar_label:"Simple Cube",tags:["examples","rendering","tutorial"],keywords:["helios","3D rendering","OpenGL","cube","tutorial"]},l="Simple Cube Rendering - Tutorial",o={},d=[{value:"What You&#39;ll Learn",id:"what-youll-learn",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Project Structure",id:"project-structure",level:2},{value:"Step-by-Step Tutorial",id:"step-by-step-tutorial",level:2},{value:"1. Application and Window Setup",id:"1-application-and-window-setup",level:3},{value:"2. Shader Creation",id:"2-shader-creation",level:3},{value:"3. Material Creation",id:"3-material-creation",level:3},{value:"4. Mesh (Geometry) Creation",id:"4-mesh-geometry-creation",level:3},{value:"5. Creating a Renderable",id:"5-creating-a-renderable",level:3},{value:"6. Scene Graph Setup",id:"6-scene-graph-setup",level:3},{value:"7. Camera and Viewport Setup",id:"7-camera-and-viewport-setup",level:3},{value:"8. Main Render Loop",id:"8-main-render-loop",level:3},{value:"Building and Running",id:"building-and-running",level:2},{value:"Expected Output",id:"expected-output",level:2},{value:"Customization Ideas",id:"customization-ideas",level:2},{value:"Change the Cube Color",id:"change-the-cube-color",level:3},{value:"Render a Solid Cube",id:"render-a-solid-cube",level:3},{value:"Adjust Rotation Speed",id:"adjust-rotation-speed",level:3},{value:"Change Rotation Axis",id:"change-rotation-axis",level:3},{value:"Key helios Concepts",id:"key-helios-concepts",level:2},{value:"Rendering Pipeline",id:"rendering-pipeline",level:3},{value:"Resource Management",id:"resource-management",level:3},{value:"Module System",id:"module-system",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Shader Compilation Errors",id:"shader-compilation-errors",level:3},{value:"Black Screen",id:"black-screen",level:3},{value:"Crash on Startup",id:"crash-on-startup",level:3},{value:"Further Reading",id:"further-reading",level:2},{value:"License",id:"license",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"simple-cube-rendering---tutorial",children:"Simple Cube Rendering - Tutorial"})}),"\n",(0,s.jsx)(n.p,{children:"This example demonstrates how to create a simple rotating wireframe cube using the helios game framework. It covers the fundamental concepts of 3D rendering, including shaders, materials, meshes, scene graphs, and the render loop."}),"\n",(0,s.jsx)(n.h2,{id:"what-youll-learn",children:"What You'll Learn"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Setting up a Helios application with OpenGL backend"}),"\n",(0,s.jsx)(n.li,{children:"Creating and configuring shaders"}),"\n",(0,s.jsx)(n.li,{children:"Building materials and meshes"}),"\n",(0,s.jsx)(n.li,{children:"Working with the scene graph"}),"\n",(0,s.jsx)(n.li,{children:"Implementing a basic render loop"}),"\n",(0,s.jsx)(n.li,{children:"Handling user input"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"helios framework properly built and installed"}),"\n",(0,s.jsx)(n.li,{children:"Basic understanding of C++ and 3D graphics concepts"}),"\n",(0,s.jsx)(n.li,{children:"Familiarity with OpenGL shader language (GLSL)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"project-structure",children:"Project Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"simple_cube_rendering/\n\u251c\u2500\u2500 main.cpp           # Main application code\n\u251c\u2500\u2500 resources/\n\u2502   \u251c\u2500\u2500 cube.vert     # Vertex shader\n\u2502   \u2514\u2500\u2500 cube.frag     # Fragment shader\n\u2514\u2500\u2500 README.md         # This file\n"})}),"\n",(0,s.jsx)(n.h2,{id:"step-by-step-tutorial",children:"Step-by-Step Tutorial"}),"\n",(0,s.jsx)(n.h3,{id:"1-application-and-window-setup",children:"1. Application and Window Setup"}),"\n",(0,s.jsxs)(n.p,{children:["First, we create an OpenGL application using the ",(0,s.jsx)(n.code,{children:"GLFWFactory"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'const auto app = GLFWFactory::makeOpenGLApp(\n    "helios - Simple Cube Renderer"\n);\n\nauto win = dynamic_cast<GLFWWindow*>(app->current());\nhelios::input::InputManager& inputManager = app->inputManager();\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"What's happening:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"GLFWFactory::makeOpenGLApp()"})," creates a complete application with a window and OpenGL context"]}),"\n",(0,s.jsx)(n.li,{children:"We retrieve the current window and input manager for later use"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-shader-creation",children:"2. Shader Creation"}),"\n",(0,s.jsx)(n.p,{children:"Shaders define how our geometry is transformed and colored. We load vertex and fragment shaders from files:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'const auto basicStringFileReader = BasicStringFileReader();\n\nauto shader_ptr = std::make_shared<OpenGLShader>(\n    "./resources/cube.vert",\n    "./resources/cube.frag",\n    basicStringFileReader\n);\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["Vertex Shader (",(0,s.jsx)(n.code,{children:"cube.vert"}),"):"]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-glsl",children:"#version 450 core\n\nlayout (location=0) in vec3 aPos;\nlayout (location=1) uniform mat4 modelMatrix;\n\nvoid main() {\n    gl_Position = modelMatrix * vec4(aPos, 1.0f);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["Fragment Shader (",(0,s.jsx)(n.code,{children:"cube.frag"}),"):"]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-glsl",children:"#version 450 core\n\nout vec4 FragColor;\n\nvoid main() {\n    FragColor = vec4(1.0f, 1.0f, 0.0f, 1.0f); // Yellow color\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Mapping Uniforms:"})}),"\n",(0,s.jsx)(n.p,{children:"We tell the shader where to find the world transformation matrix:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto uniformLocationMap = std::make_unique<OpenGLUniformLocationMap>();\nuniformLocationMap->set(UniformSemantics::ModelMatrix, 1);\nshader_ptr->setUniformLocationMap(std::move(uniformLocationMap));\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-material-creation",children:"3. Material Creation"}),"\n",(0,s.jsx)(n.p,{children:"Materials combine shaders with properties like color and roughness:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto cubeMaterialProps = MaterialProperties(\n    helios::math::vec4f(1.0f, 0.0f, 1.0f, 1.0f), // Magenta RGBA\n    0.0f  // Roughness (0 = smooth, 1 = rough)\n);\n\nauto cubeMaterialProps_shared = std::make_shared<MaterialProperties>(cubeMaterialProps);\nauto material_ptr = std::make_shared<Material>(\n    shader_ptr, cubeMaterialProps_shared\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," The material color is currently not used by the fragment shader (which hardcodes yellow). To use the material color, modify the fragment shader to accept a uniform."]}),"\n",(0,s.jsx)(n.h3,{id:"4-mesh-geometry-creation",children:"4. Mesh (Geometry) Creation"}),"\n",(0,s.jsxs)(n.p,{children:["A mesh defines the 3D shape. We use helios's built-in ",(0,s.jsx)(n.code,{children:"Cube"})," shape:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto cube = Cube{};\n\nauto meshConfig = std::make_shared<const MeshConfig>(\n    PrimitiveType::LineLoop  // Render as wireframe\n);\n\nauto mesh_ptr = std::make_shared<OpenGLMesh>(cube, meshConfig);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Primitive Types:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"PrimitiveType::Triangles"})," - Solid filled geometry"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"PrimitiveType::LineLoop"})," - Wireframe outline"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"PrimitiveType::Lines"})," - Individual line segments"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"PrimitiveType::Points"})," - Vertex points"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"5-creating-a-renderable",children:"5. Creating a Renderable"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"RenderPrototype"})," combines a material with a mesh, and a ",(0,s.jsx)(n.code,{children:"Renderable"})," makes it instantiable:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"const auto renderPrototype = std::make_shared<RenderPrototype>(\n    material_ptr, mesh_ptr\n);\n\nauto cubeRenderable = std::make_shared<Renderable>(renderPrototype);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"6-scene-graph-setup",children:"6. Scene Graph Setup"}),"\n",(0,s.jsx)(n.p,{children:"The scene graph organizes objects in 3D space. We create a scene and add our cube:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto frustumCullingStrategy = std::make_unique<CullNoneStrategy>();\nauto scene = std::make_unique<Scene>(std::move(frustumCullingStrategy));\n\nauto cubeSceneNode = std::make_unique<SceneNode>(std::move(cubeRenderable));\nauto* cubeNode = scene->addNode(std::move(cubeSceneNode));\n\n// Scale the cube to half its original size\ncubeNode->setScale(vec3f(0.5f, 0.5f, 0.5f));\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Scene Graph Concepts:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scene"}),": The root container for all objects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SceneNode"}),": An object in the scene with a transform (position, rotation, scale)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Culling Strategy"}),": Determines which objects are visible (here: render everything)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"7-camera-and-viewport-setup",children:"7. Camera and Viewport Setup"}),"\n",(0,s.jsxs)(n.p,{children:["The camera defines the viewpoint from which we observe the scene. In helios, cameras are integrated into the scene graph via ",(0,s.jsx)(n.code,{children:"CameraSceneNode"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Create viewport\nauto mainViewport = std::make_shared<Viewport>(0.0f, 0.0f, 1.0f, 1.0f);\nwin->addViewport(mainViewport);\n\n// Create camera with projection settings\nauto camera = std::make_unique<Camera>();\ncamera->setPerspective(\n    helios::math::radians(90.0f),  // FOV in radians\n    16.0f / 9.0f,                   // Aspect ratio\n    0.1f,                           // Near plane\n    1000.0f                         // Far plane\n);\n\n// Add camera to scene graph\nauto cameraNode = std::make_unique<CameraSceneNode>(std::move(camera));\nauto* camPtr = scene->addNode(std::move(cameraNode));\n\n// Position the camera\ncamPtr->setTranslation(vec3f(0.0f, 0.0f, 3.0f));\ncamPtr->lookAt(vec3f(0.0f, 0.0f, 0.0f), vec3f(0.0f, 1.0f, 0.0f));\n\n// Connect viewport to camera\nmainViewport->setCameraSceneNode(camPtr);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Camera Concepts:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Camera"}),": Defines projection parameters (FOV, aspect ratio, near/far planes)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CameraSceneNode"}),": Scene graph node that owns the camera and computes the view matrix"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Viewport"}),": Defines the render target area and references the active camera"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"8-main-render-loop",children:"8. Main Render Loop"}),"\n",(0,s.jsx)(n.p,{children:"The render loop updates the scene and draws each frame:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"float degrees = 0.0f;\nconstexpr float rotationSpeed = 2.25f;\n\nwhile (!win->shouldClose()) {\n    // 1. Process events\n    app->eventManager().dispatchAll();\n    inputManager.poll(0.0f);\n\n    // 2. Handle input (ESC to quit)\n    if (inputManager.isKeyPressed(Key::ESC)) {\n        win->setShouldClose(true);\n    }\n\n    // 3. Update rotation\n    degrees += rotationSpeed;\n    if (degrees >= 360.0f) {\n        degrees -= 360.0f;\n    }\n\n    // 4. Apply transformation\n    float rad = helios::math::radians(degrees);\n    cubeNode->setRotation(helios::math::rotate(\n        helios::math::mat4f::identity(),\n        rad,\n        helios::math::vec3f(0.4f, 0.6f, 0.2f) // Rotation axis\n    ));\n\n    // 5. Render the scene\n    const auto& snapshot = scene->createSnapshot(mainViewport);\n    if (snapshot.has_value()) {\n        auto renderPass = RenderPassFactory::getInstance().buildRenderPass(*snapshot);\n        app->renderingDevice().render(renderPass);\n    }\n\n    // 6. Swap buffers (display the result)\n    win->swapBuffers();\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Render Loop Breakdown:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event Processing"}),": Handle window events (resize, close, etc.)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Input Handling"}),": Check for keyboard/mouse input"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Update Logic"}),": Modify object transformations (rotation, position, etc.)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rendering"}),": Create snapshot from viewport's camera and render it"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Buffer Swap"}),": Display the rendered frame"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"building-and-running",children:"Building and Running"}),"\n",(0,s.jsx)(n.p,{children:"From the project root directory:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Configure the build\ncmake -S . -B build -DCMAKE_BUILD_TYPE=Release\n\n# Build the project\ncmake --build build --config Release\n\n# Run the example\ncd build/examples/simple_cube_rendering/Release\n./simple_cube_rendering.exe\n"})}),"\n",(0,s.jsx)(n.h2,{id:"expected-output",children:"Expected Output"}),"\n",(0,s.jsxs)(n.p,{children:["You should see a window displaying a rotating yellow wireframe cube. Press ",(0,s.jsx)(n.code,{children:"ESC"})," to exit."]}),"\n",(0,s.jsx)(n.h2,{id:"customization-ideas",children:"Customization Ideas"}),"\n",(0,s.jsx)(n.h3,{id:"change-the-cube-color",children:"Change the Cube Color"}),"\n",(0,s.jsxs)(n.p,{children:["Modify ",(0,s.jsx)(n.code,{children:"cube.frag"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-glsl",children:"void main() {\n    FragColor = vec4(0.0f, 1.0f, 0.0f, 1.0f); // Green cube\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"render-a-solid-cube",children:"Render a Solid Cube"}),"\n",(0,s.jsxs)(n.p,{children:["Change the primitive type in ",(0,s.jsx)(n.code,{children:"main.cpp"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto meshConfig = std::make_shared<const MeshConfig>(\n    PrimitiveType::Triangles  // Changed from LineLoop\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"adjust-rotation-speed",children:"Adjust Rotation Speed"}),"\n",(0,s.jsx)(n.p,{children:"Modify the rotation speed constant:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"constexpr float rotationSpeed = 5.0f; // Faster rotation\n"})}),"\n",(0,s.jsx)(n.h3,{id:"change-rotation-axis",children:"Change Rotation Axis"}),"\n",(0,s.jsx)(n.p,{children:"Modify the rotation axis vector:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"helios::math::vec3f(1.0f, 0.0f, 0.0f) // Rotate around X-axis\n"})}),"\n",(0,s.jsx)(n.h2,{id:"key-helios-concepts",children:"Key helios Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"rendering-pipeline",children:"Rendering Pipeline"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scene Graph"})," \u2192 Hierarchical organization of objects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Snapshot"})," \u2192 Frozen state of the scene at a moment in time"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"RenderPass"})," \u2192 Collection of render commands for the GPU"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"RenderQueue"})," \u2192 Ordered list of objects to render"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"RenderCommand"})," \u2192 Individual draw call with uniforms"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"resource-management",children:"Resource Management"}),"\n",(0,s.jsxs)(n.p,{children:["helios uses ",(0,s.jsx)(n.code,{children:"std::shared_ptr"})," for shared resources (shaders, materials, meshes) and ",(0,s.jsx)(n.code,{children:"std::unique_ptr"})," for owned resources (scene nodes, render passes)."]}),"\n",(0,s.jsx)(n.h3,{id:"module-system",children:"Module System"}),"\n",(0,s.jsxs)(n.p,{children:["helios uses C++23 modules (",(0,s.jsx)(n.code,{children:"import"})," statements) instead of traditional ",(0,s.jsx)(n.code,{children:"#include"})," headers for better compile times and cleaner dependencies."]}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsx)(n.h3,{id:"shader-compilation-errors",children:"Shader Compilation Errors"}),"\n",(0,s.jsx)(n.p,{children:"Check the console output for shader compilation errors. Common issues:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Incorrect shader file paths"}),"\n",(0,s.jsx)(n.li,{children:"GLSL syntax errors"}),"\n",(0,s.jsx)(n.li,{children:"Unsupported GLSL version"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"black-screen",children:"Black Screen"}),"\n",(0,s.jsx)(n.p,{children:"Ensure:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Shaders are compiling successfully"}),"\n",(0,s.jsx)(n.li,{children:"The camera is positioned correctly"}),"\n",(0,s.jsx)(n.li,{children:"The cube is within the view frustum"}),"\n",(0,s.jsx)(n.li,{children:"OpenGL context is properly initialized"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"crash-on-startup",children:"Crash on Startup"}),"\n",(0,s.jsx)(n.p,{children:"Verify:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"All shared resources are properly initialized"}),"\n",(0,s.jsxs)(n.li,{children:["Shader files exist in the ",(0,s.jsx)(n.code,{children:"resources/"})," directory"]}),"\n",(0,s.jsx)(n.li,{children:"CMake build completed without errors"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/api/overview",children:"helios API Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/contributing/styleguide",children:"helios Coding Style Guide"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://learnopengl.com/",children:"OpenGL Tutorial"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.khronos.org/opengl/wiki/OpenGL_Shading_Language",children:"GLSL Reference"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"license",children:"License"}),"\n",(0,s.jsx)(n.p,{children:"This example is part of the helios framework and is distributed under the MIT License."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>l});var i=r(96540);const s={},a=i.createContext(s);function t(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);