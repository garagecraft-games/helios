"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[35144],{28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>i});var s=r(96540);const a={},t=s.createContext(a);function o(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(t.Provider,{value:n},e.children)}},67180:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"core-concepts/scene-graph","title":"Scene Graph","description":"The scene graph is a hierarchical data structure that organizes all objects in your 3D world. It provides automatic transform propagation from parent to child nodes.","source":"@site/docs/core-concepts/scene-graph.md","sourceDirName":"core-concepts","slug":"/core-concepts/scene-graph","permalink":"/docs/core-concepts/scene-graph","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/core-concepts/scene-graph.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Conventions","permalink":"/docs/core-concepts/conventions"},"next":{"title":"Overview","permalink":"/docs/examples"}}');var a=r(74848),t=r(28453);const o={sidebar_position:1},i="Scene Graph",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Key Classes",id:"key-classes",level:2},{value:"<code>Scene</code>",id:"scene",level:3},{value:"<code>SceneNode</code>",id:"scenenode",level:3},{value:"<code>Camera</code>",id:"camera",level:3},{value:"Transform Propagation",id:"transform-propagation",level:2},{value:"Culling Strategies",id:"culling-strategies",level:2},{value:"Creating a Snapshot",id:"creating-a-snapshot",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Example: Solar System",id:"example-solar-system",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"scene-graph",children:"Scene Graph"})}),"\n",(0,a.jsx)(n.p,{children:"The scene graph is a hierarchical data structure that organizes all objects in your 3D world. It provides automatic transform propagation from parent to child nodes."}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsxs)(n.p,{children:["helios uses a ",(0,a.jsx)(n.strong,{children:"tree-based scene graph"})," where each node can have:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"A local transformation (position, rotation, scale)"}),"\n",(0,a.jsx)(n.li,{children:"A world transformation (computed from parent hierarchy)"}),"\n",(0,a.jsx)(n.li,{children:"An optional renderable (mesh + material)"}),"\n",(0,a.jsx)(n.li,{children:"Child nodes"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"key-classes",children:"Key Classes"}),"\n",(0,a.jsx)(n.h3,{id:"scene",children:(0,a.jsx)(n.code,{children:"Scene"})}),"\n",(0,a.jsx)(n.p,{children:"The root container for all scene objects."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"import helios.scene.Scene;\nimport helios.scene.CullNoneStrategy;\n\nauto scene = std::make_unique<Scene>(\n    std::make_unique<CullNoneStrategy>()\n);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"scenenode",children:(0,a.jsx)(n.code,{children:"SceneNode"})}),"\n",(0,a.jsx)(n.p,{children:"A node in the scene graph hierarchy."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"import helios.scene.SceneNode;\n\n// Create a node with a renderable\nauto node = std::make_unique<SceneNode>(std::move(renderable));\n\n// Add as child to scene\nauto* nodePtr = scene->addNode(std::move(node));\n\n// Transform the node\nnodePtr->translate(vec3f(0.0f, 2.0f, 0.0f));\nnodePtr->rotate(rotationMatrix);\nnodePtr->scale(vec3f(0.5f, 0.5f, 0.5f));\n"})}),"\n",(0,a.jsx)(n.h3,{id:"camera",children:(0,a.jsx)(n.code,{children:"Camera"})}),"\n",(0,a.jsx)(n.p,{children:"Defines the viewpoint and projection."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"import helios.scene.Camera;\n\nauto camera = std::make_unique<Camera>();\nscene->addNode(std::move(camera));\n"})}),"\n",(0,a.jsx)(n.h2,{id:"transform-propagation",children:"Transform Propagation"}),"\n",(0,a.jsx)(n.p,{children:"Transformations automatically propagate from parent to child:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Root (identity)\n  \u2193\nParent (translate(0, 2, 0))\n  \u2193\nChild (rotate(45\xb0))\n  \u2192 Final transform: translate + rotate\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"// Create parent-child hierarchy\nauto parentNode = std::make_unique<SceneNode>();\nauto* parent = scene->addNode(std::move(parentNode));\n\nauto childNode = std::make_unique<SceneNode>(std::move(renderable));\nauto* child = parent->addChild(std::move(childNode));\n\n// Transform parent\nparent->translate(vec3f(0.0f, 2.0f, 0.0f));\n\n// Child automatically inherits parent's transform\n// and applies its own on top\nchild->rotate(rotationMatrix);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"culling-strategies",children:"Culling Strategies"}),"\n",(0,a.jsx)(n.p,{children:"The scene graph supports pluggable culling strategies to determine which objects are visible:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"CullNoneStrategy"})}),": Renders all objects (no culling)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"FrustumCullingStrategy"})}),": Only renders objects in camera frustum"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"auto frustumCulling = std::make_unique<FrustumCullingStrategy>();\nauto scene = std::make_unique<Scene>(std::move(frustumCulling));\n"})}),"\n",(0,a.jsx)(n.h2,{id:"creating-a-snapshot",children:"Creating a Snapshot"}),"\n",(0,a.jsxs)(n.p,{children:["The scene creates a ",(0,a.jsx)(n.strong,{children:"snapshot"})," of visible objects for rendering:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"// Create immutable snapshot of current scene state\nconst auto& snapshot = scene->createSnapshot(*camera);\n\n// Snapshot contains:\n// - View matrix\n// - Projection matrix\n// - List of visible renderables with world transforms\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Minimize scene graph depth"}),": Flatten hierarchies where possible for better performance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Update only when needed"}),": Transformations are cached and only recomputed when changed"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use culling"}),": Enable frustum culling for large scenes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Batch by material"}),": Group objects with the same material together"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"example-solar-system",children:"Example: Solar System"}),"\n",(0,a.jsx)(n.admonition,{title:"Simplified Example",type:"note",children:(0,a.jsxs)(n.p,{children:["This example demonstrates the scene graph hierarchy. Renderable creation (sunRenderable, earthRenderable, moonRenderable) and rotation matrix calculations are omitted for clarity. See ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"https://github.com/thorstensuckow/helios/tree/main/examples/simple_cube_rendering",children:"examples/simple_cube_rendering"})})," for complete implementations."]})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"// Sun at center\nauto sunNode = std::make_unique<SceneNode>(std::move(sunRenderable));\nauto* sun = scene->addNode(std::move(sunNode));\n\n// Earth orbits sun\nauto earthNode = std::make_unique<SceneNode>(std::move(earthRenderable));\nauto* earth = sun->addChild(std::move(earthNode));\nearth->translate(vec3f(10.0f, 0.0f, 0.0f));\n\n// Moon orbits earth\nauto moonNode = std::make_unique<SceneNode>(std::move(moonRenderable));\nauto* moon = earth->addChild(std::move(moonNode));\nmoon->translate(vec3f(2.0f, 0.0f, 0.0f));\n\n// Animate orbits in game loop\nsun->rotate(sunRotation);\nearth->rotate(earthRotation);\nmoon->rotate(moonRotation);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"../rendering-pipeline",children:"Rendering Pipeline"})," - How snapshots become draw calls"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"./camera",children:"Camera"})," - Camera setup and projection"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"../api/overview",children:"API Reference"})," - Full API documentation"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);