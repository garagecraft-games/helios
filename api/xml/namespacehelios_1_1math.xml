<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="namespacehelios_1_1math" kind="namespace" language="C++">
    <compoundname>helios::math</compoundname>
    <innerclass refid="structhelios_1_1math_1_1aabb" prot="public">helios::math::aabb</innerclass>
    <innerclass refid="structhelios_1_1math_1_1mat4" prot="public">helios::math::mat4</innerclass>
    <innerclass refid="structhelios_1_1math_1_1vec3" prot="public">helios::math::vec3</innerclass>
    <innerclass refid="structhelios_1_1math_1_1vec2" prot="public">helios::math::vec2</innerclass>
    <innerclass refid="structhelios_1_1math_1_1vec4" prot="public">helios::math::vec4</innerclass>
    <innerconcept refid="concepthelios_1_1math_1_1Numeric">helios::math::Numeric</innerconcept>
    <innernamespace refid="namespacehelios_1_1math_1_1concepts">helios::math::concepts</innernamespace>
    <innernamespace refid="namespacehelios_1_1math_1_1transform">helios::math::transform</innernamespace>
    <innernamespace refid="namespacehelios_1_1math_1_1types">helios::math::types</innernamespace>
    <sectiondef kind="enum">
      <memberdef kind="enum" id="namespacehelios_1_1math_1a27682cda52181a23edab8c0249fa531d" prot="public" static="no" strong="yes">
        <type>uint8_t</type>
        <name>TransformType</name>
        <qualifiedname>helios::math::TransformType</qualifiedname>
        <enumvalue id="namespacehelios_1_1math_1a27682cda52181a23edab8c0249fa531da6dd08874f83507e9c7b23f1a46b7fa7c" prot="public">
          <name>Translation</name>
          <initializer>= 1 &lt;&lt; 0</initializer>
          <briefdescription>
<para>Inherit only the translation component from the parent. </para>
          </briefdescription>
          <detaileddescription>
<para>The child&apos;s world position is offset by the parent&apos;s world position, but rotation and scale remain unaffected by the parent. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacehelios_1_1math_1a27682cda52181a23edab8c0249fa531daf1a42bd417390fc63b030a519624607a" prot="public">
          <name>Rotation</name>
          <initializer>= 1 &lt;&lt; 1</initializer>
          <briefdescription>
<para>Inherit only the rotation component from the parent. </para>
          </briefdescription>
          <detaileddescription>
<para>The child&apos;s orientation is combined with the parent&apos;s orientation, but position and scale remain unaffected. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacehelios_1_1math_1a27682cda52181a23edab8c0249fa531da85a7cd587d6142dbfc1a4de05af7b75d" prot="public">
          <name>Scale</name>
          <initializer>= 1 &lt;&lt; 2</initializer>
          <briefdescription>
<para>Inherit only the scale component from the parent. </para>
          </briefdescription>
          <detaileddescription>
<para>The child&apos;s scale is multiplied by the parent&apos;s scale, but position and rotation remain unaffected. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacehelios_1_1math_1a27682cda52181a23edab8c0249fa531dab1c94ca2fbc3e78fc30069c8d0f01680" prot="public">
          <name>All</name>
          <initializer>= Translation | Rotation | Scale</initializer>
          <briefdescription>
<para>Inherit all transform components (Translation, Rotation, Scale). </para>
          </briefdescription>
          <detaileddescription>
<para>This is the default behavior where the child&apos;s world transform is the full composition of parent and local transforms. </para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Bitmask enum controlling which transform components a child node inherits from its parent. </para>
        </briefdescription>
        <detaileddescription>
<para>When a SceneNode is attached to a parent, its final world transform is computed by combining the parent&apos;s world transform with the child&apos;s local transform. The `Inherit` flags determine which components (Translation, Rotation, Scale) of the parent transform are applied to the child.</para>
<para>This enables flexible scene graph behaviors such as:<itemizedlist>
<listitem><para>A camera that follows an object&apos;s position but maintains its own orientation (`TransformType::Translation`)</para>
</listitem><listitem><para>UI elements that inherit full transforms (`TransformType::All`)</para>
</listitem><listitem><para>Objects that only inherit rotation for billboard effects (`TransformType::Rotation`)</para>
</listitem></itemizedlist>
</para>
<para>Example usage: ```cpp using namespace <ref refid="namespacehelios_1_1math" kindref="compound">helios::math</ref>;</para>
<para>// Camera follows spaceship position only cameraNode-&gt;setInheritance(TransformType::Translation);</para>
<para>// Full transform inheritance (default) childNode-&gt;setInheritance(TransformType::All);</para>
<para>// Combine specific flags node-&gt;setInheritance(<ref refid="namespacehelios_1_1math_1a27682cda52181a23edab8c0249fa531da6dd08874f83507e9c7b23f1a46b7fa7c" kindref="member">TransformType::Translation</ref> | <ref refid="namespacehelios_1_1math_1a27682cda52181a23edab8c0249fa531daf1a42bd417390fc63b030a519624607a" kindref="member">TransformType::Rotation</ref>); ``` </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/TransformType.ixx" line="41" column="5" bodyfile="include/helios/math/TransformType.ixx" bodystart="41" bodyend="73"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespacehelios_1_1math_1a4c90766d59f3c1ce32821bbbd3cdd62b" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::conditional_t&lt; std::is_floating_point_v&lt; T &gt;, T, double &gt;</type>
        <definition>using helios::math::FloatingPointType =  std::conditional_t&lt;
        std::is_floating_point_v&lt;T&gt;,
        T,
        double
    &gt;</definition>
        <argsstring></argsstring>
        <name>FloatingPointType</name>
        <qualifiedname>helios::math::FloatingPointType</qualifiedname>
        <briefdescription>
<para>Type trait that promotes integral types to double, while preserving floating-point types. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>the input type </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/traits/FloatingPointTypeTrait.ixx" line="18" column="5" bodyfile="include/helios/math/traits/FloatingPointTypeTrait.ixx" bodystart="18" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1a124c0492430aeecedc1c1a5ece4ba488" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1aabb" kindref="compound">aabb</ref>&lt; float &gt;</type>
        <definition>using helios::math::aabbf =  aabb&lt;float&gt;</definition>
        <argsstring></argsstring>
        <name>aabbf</name>
        <qualifiedname>helios::math::aabbf</qualifiedname>
        <briefdescription>
<para>Single-precision floating-point AABB. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/aabb.ixx" line="202" column="5" bodyfile="include/helios/math/types/aabb.ixx" bodystart="202" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1a3c63775a7d6ff09058288223291660b7" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1aabb" kindref="compound">aabb</ref>&lt; int &gt;</type>
        <definition>using helios::math::aabbi =  aabb&lt;int&gt;</definition>
        <argsstring></argsstring>
        <name>aabbi</name>
        <qualifiedname>helios::math::aabbi</qualifiedname>
        <briefdescription>
<para>Integer AABB. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/aabb.ixx" line="207" column="5" bodyfile="include/helios/math/types/aabb.ixx" bodystart="207" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1a8cdcd5dfceca20081416ef7ac3374e01" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1aabb" kindref="compound">aabb</ref>&lt; double &gt;</type>
        <definition>using helios::math::aabbd =  aabb&lt;double&gt;</definition>
        <argsstring></argsstring>
        <name>aabbd</name>
        <qualifiedname>helios::math::aabbd</qualifiedname>
        <briefdescription>
<para>Double-precision floating-point AABB. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/aabb.ixx" line="212" column="5" bodyfile="include/helios/math/types/aabb.ixx" bodystart="212" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1mat4" kindref="compound">mat4</ref>&lt; float &gt;</type>
        <definition>using helios::math::mat4f =  mat4&lt;float&gt;</definition>
        <argsstring></argsstring>
        <name>mat4f</name>
        <qualifiedname>helios::math::mat4f</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/mat4.ixx" line="395" column="5" bodyfile="include/helios/math/types/mat4.ixx" bodystart="395" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1a058bd8629e8b9fdd7914ec513cf515f5" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1mat4" kindref="compound">mat4</ref>&lt; double &gt;</type>
        <definition>using helios::math::mat4d =  mat4&lt;double&gt;</definition>
        <argsstring></argsstring>
        <name>mat4d</name>
        <qualifiedname>helios::math::mat4d</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/mat4.ixx" line="396" column="5" bodyfile="include/helios/math/types/mat4.ixx" bodystart="396" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1abfde83491c8def2cca7e8816bb9a0075" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1mat4" kindref="compound">mat4</ref>&lt; int &gt;</type>
        <definition>using helios::math::mat4i =  mat4&lt;int&gt;</definition>
        <argsstring></argsstring>
        <name>mat4i</name>
        <qualifiedname>helios::math::mat4i</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/mat4.ixx" line="397" column="5" bodyfile="include/helios/math/types/mat4.ixx" bodystart="397" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1aeab5c7e555a142f8f763a3317460d5c0" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1vec2" kindref="compound">vec2</ref>&lt; float &gt;</type>
        <definition>using helios::math::vec2f =  vec2&lt;float&gt;</definition>
        <argsstring></argsstring>
        <name>vec2f</name>
        <qualifiedname>helios::math::vec2f</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec2.ixx" line="192" column="5" bodyfile="include/helios/math/types/vec2.ixx" bodystart="192" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1acb8f1b0c5acc937254f38e27787db452" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1vec2" kindref="compound">vec2</ref>&lt; double &gt;</type>
        <definition>using helios::math::vec2d =  vec2&lt;double&gt;</definition>
        <argsstring></argsstring>
        <name>vec2d</name>
        <qualifiedname>helios::math::vec2d</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec2.ixx" line="193" column="5" bodyfile="include/helios/math/types/vec2.ixx" bodystart="193" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1aff32bafe25abeda0bb858b51ae46bff8" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1vec2" kindref="compound">vec2</ref>&lt; int &gt;</type>
        <definition>using helios::math::vec2i =  vec2&lt;int&gt;</definition>
        <argsstring></argsstring>
        <name>vec2i</name>
        <qualifiedname>helios::math::vec2i</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec2.ixx" line="194" column="5" bodyfile="include/helios/math/types/vec2.ixx" bodystart="194" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1a71f1e40e636f47229c3122bdb63099d5" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; float &gt;</type>
        <definition>using helios::math::vec3f =  vec3&lt;float&gt;</definition>
        <argsstring></argsstring>
        <name>vec3f</name>
        <qualifiedname>helios::math::vec3f</qualifiedname>
        <briefdescription>
<para>Single-precision floating-point 3D vector. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="369" column="5" bodyfile="include/helios/math/types/vec3.ixx" bodystart="369" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1a0fd329cdb93d866fad284b88f7acb4f4" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; int &gt;</type>
        <definition>using helios::math::vec3i =  vec3&lt;int&gt;</definition>
        <argsstring></argsstring>
        <name>vec3i</name>
        <qualifiedname>helios::math::vec3i</qualifiedname>
        <briefdescription>
<para>Integer 3D vector. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="374" column="5" bodyfile="include/helios/math/types/vec3.ixx" bodystart="374" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1a57c950d4cb887c103dc2423f3ea81ce4" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; double &gt;</type>
        <definition>using helios::math::vec3d =  vec3&lt;double&gt;</definition>
        <argsstring></argsstring>
        <name>vec3d</name>
        <qualifiedname>helios::math::vec3d</qualifiedname>
        <briefdescription>
<para>Double-precision floating-point 3D vector. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="379" column="5" bodyfile="include/helios/math/types/vec3.ixx" bodystart="379" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1a08252f81850c5902e3c8dead272f3332" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1vec4" kindref="compound">vec4</ref>&lt; float &gt;</type>
        <definition>using helios::math::vec4f =  vec4&lt;float&gt;</definition>
        <argsstring></argsstring>
        <name>vec4f</name>
        <qualifiedname>helios::math::vec4f</qualifiedname>
        <briefdescription>
<para>Single-precision floating-point 4D vector. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec4.ixx" line="136" column="5" bodyfile="include/helios/math/types/vec4.ixx" bodystart="136" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1a78a0f495523b71681b549f098f994126" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1vec4" kindref="compound">vec4</ref>&lt; double &gt;</type>
        <definition>using helios::math::vec4d =  vec4&lt;double&gt;</definition>
        <argsstring></argsstring>
        <name>vec4d</name>
        <qualifiedname>helios::math::vec4d</qualifiedname>
        <briefdescription>
<para>Double-precision floating-point 4D vector. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec4.ixx" line="141" column="5" bodyfile="include/helios/math/types/vec4.ixx" bodystart="141" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1a9ce6ecf5869b53d92a26354e2c48d0b4" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1vec4" kindref="compound">vec4</ref>&lt; int &gt;</type>
        <definition>using helios::math::vec4i =  vec4&lt;int&gt;</definition>
        <argsstring></argsstring>
        <name>vec4i</name>
        <qualifiedname>helios::math::vec4i</qualifiedname>
        <briefdescription>
<para>Integer 4D vector. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec4.ixx" line="146" column="5" bodyfile="include/helios/math/types/vec4.ixx" bodystart="146" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="var">
      <memberdef kind="variable" id="namespacehelios_1_1math_1af25d93f23f91acae02abfd7706b2e36d" prot="public" static="no" constexpr="yes" mutable="no">
        <type>float</type>
        <definition>float helios::math::EPSILON_LENGTH</definition>
        <argsstring></argsstring>
        <name>EPSILON_LENGTH</name>
        <qualifiedname>helios::math::EPSILON_LENGTH</qualifiedname>
        <initializer>= 1e-6f</initializer>
        <briefdescription>
<para>A small epsilon value used for length-based comparisons. </para>
        </briefdescription>
        <detaileddescription>
<para>This constant represents the minimum threshold value for length comparisons to account for numerical precision errors in floating-point calculations. It is often used to avoid treating very small values as significant, effectively filtering out noise in computations that involve vector-lengths. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/utils.ixx" line="22" column="21" bodyfile="include/helios/math/utils.ixx" bodystart="22" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="namespacehelios_1_1math_1a3009ee1714550dc2af4d7e5e952e8a90" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref></type>
        <definition>mat4f helios::math::perspective</definition>
        <argsstring>(float fovY, float aspect, float zNear, float zFar) noexcept</argsstring>
        <name>perspective</name>
        <qualifiedname>helios::math::perspective</qualifiedname>
        <param>
          <type>float</type>
          <declname>fovY</declname>
        </param>
        <param>
          <type>float</type>
          <declname>aspect</declname>
        </param>
        <param>
          <type>float</type>
          <declname>zNear</declname>
        </param>
        <param>
          <type>float</type>
          <declname>zFar</declname>
        </param>
        <briefdescription>
<para>Computes the 4x4 perspective projection matrix based on the specified field of view, aspect ratio, and near and far clipping planes. </para>
        </briefdescription>
        <detaileddescription>
<para>This method returns a matrix suitable for projecting 3D points onto a 2D screen from the perspective of a camera. The perspective transformation maps 3D points inside the specified viewing frustum to normalized device coordinates, which are then clipped and transformed to screen space.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fovY</parametername>
</parameternamelist>
<parameterdescription>
<para>Field of view in the Y direction, specified in radians. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>aspect</parametername>
</parameternamelist>
<parameterdescription>
<para>The aspect ratio of the view, defined as width divided by height. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zNear</parametername>
</parameternamelist>
<parameterdescription>
<para>The distance to the near clipping plane. Must be greater than zero. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zFar</parametername>
</parameternamelist>
<parameterdescription>
<para>The distance to the far clipping plane. Must be greater than zNear.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A 4x4 matrix representing the perspective projection transformation.</para>
</simplesect>
<simplesect kind="see"><para><ulink url="https://thorsten.suckow-homberg.de/docs/articles/computer-graphics/from-camera-to-clip-space-derivation-of-the-projection-matrices">https://thorsten.suckow-homberg.de/docs/articles/computer-graphics/from-camera-to-clip-space-derivation-of-the-projection-matrices</ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/transform/camera.ixx" line="33" column="11" declfile="include/helios/math/transform/camera.ixx" declline="33" declcolumn="11"/>
        <referencedby refid="classhelios_1_1scene_1_1Camera_1a949fcc8b4e43f2a9afdad8eaafaeb07b" compoundref="Camera_8ixx" startline="76" endline="85">helios::scene::Camera::update</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1aef6bef7ca3d31a4908a66e16c9771420" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref></type>
        <definition>mat4f helios::math::lookAt</definition>
        <argsstring>(const vec3f &amp;eye, const vec3f &amp;center, const vec3f &amp;up) noexcept</argsstring>
        <name>lookAt</name>
        <qualifiedname>helios::math::lookAt</qualifiedname>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1a71f1e40e636f47229c3122bdb63099d5" kindref="member">vec3f</ref> &amp;</type>
          <declname>eye</declname>
        </param>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1a71f1e40e636f47229c3122bdb63099d5" kindref="member">vec3f</ref> &amp;</type>
          <declname>center</declname>
        </param>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1a71f1e40e636f47229c3122bdb63099d5" kindref="member">vec3f</ref> &amp;</type>
          <declname>up</declname>
        </param>
        <briefdescription>
<para>Returns the 4x4 lookAt-matrix for transforming world coordinates to camera space. The method creates the camera coordinate system based on the parameters eye, i.e. the vantage point in world space, the camera&apos;s up direction and center, representing the point of interest. Note that the returned matrix is essentially a composition of a change of coordinates matrix P(C &lt;- W) and a translation to the origin, i.e. the camera is sitting at the origin (0, 0, 0) looking down the negative z-axis, i.e. conceptually. </para>
        </briefdescription>
        <detaileddescription>
<para>P(W&lt;-C) * T(-eye)</para>
<para>The 4x4 matrix can then be used for computing the perspective projection for creating the clip space</para>
<para>clip = P * V * W * M</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>eye</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>center</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>up</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/transform/camera.ixx" line="58" column="11" declfile="include/helios/math/transform/camera.ixx" declline="58" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a643691235959c2f53d144a4ee9a0e251" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref></type>
        <definition>mat4f helios::math::rotate</definition>
        <argsstring>(const mat4f &amp;model, float radians, const vec3f &amp;axis) noexcept</argsstring>
        <name>rotate</name>
        <qualifiedname>helios::math::rotate</qualifiedname>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>float</type>
          <declname>radians</declname>
        </param>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1a71f1e40e636f47229c3122bdb63099d5" kindref="member">vec3f</ref> &amp;</type>
          <declname>axis</declname>
        </param>
        <briefdescription>
<para>Creates an affine rotation matrix R&apos; = M * R by &quot;baking&quot; the rotation part into the model matrix. Any operation R&apos; * v will make sure that v is rotated around the local origin, then transformed into world space. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>model</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>radians</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>axis</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/transform/model.ixx" line="23" column="11" declfile="include/helios/math/transform/model.ixx" declline="23" declcolumn="11"/>
        <references refid="namespacehelios_1_1math_1a4949642a7cca09c7950bb6a1b75260c9" compoundref="utils_8ixx" startline="30" endline="32">radians</references>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1addafb8dbe33d09352658b55cee9a0898" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref></type>
        <definition>mat4f helios::math::translate</definition>
        <argsstring>(const mat4f &amp;model, const vec3f &amp;v) noexcept</argsstring>
        <name>translate</name>
        <qualifiedname>helios::math::translate</qualifiedname>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1a71f1e40e636f47229c3122bdb63099d5" kindref="member">vec3f</ref> &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Creates an affine transformation matrix M&apos; = M * T by &quot;baking&quot; the translation part into the model matrix. Any operation M&apos; * v will make sure that v is translated in local space, then transformed into world space. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>model</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/transform/model.ixx" line="35" column="22" bodyfile="include/helios/math/transform/model.ixx" bodystart="35" bodyend="41"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1ae230dbf0f416c8c868d5fea73d6babdb" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref></type>
        <definition>mat4f helios::math::scale</definition>
        <argsstring>(const mat4f &amp;model, const vec3f &amp;v) noexcept</argsstring>
        <name>scale</name>
        <qualifiedname>helios::math::scale</qualifiedname>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1a71f1e40e636f47229c3122bdb63099d5" kindref="member">vec3f</ref> &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Creates an affine transformation matrix S&apos; = M * S by &quot;&quot;baking" the scaling part into the model matrix. Any operation S&apos; * v will make sure that v is scaled in local space, then transformed into world space. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>model</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/transform/model.ixx" line="53" column="21" bodyfile="include/helios/math/transform/model.ixx" bodystart="53" bodyend="61"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a8cc238c96b9b131d26357870e87ed668" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref></type>
        <definition>mat4f helios::math::scale</definition>
        <argsstring>(const mat4f &amp;model, const float scale_by) noexcept</argsstring>
        <name>scale</name>
        <qualifiedname>helios::math::scale</qualifiedname>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const float</type>
          <declname>scale_by</declname>
        </param>
        <briefdescription>
<para>Creates an affine transformation matrix S&apos; = M * S by &quot;baking&quot; the scaling part into the model matrix. Any operation S&apos; * v will make sure that v is scaled in local space, then transformed into world space. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>model</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scale_by</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/transform/model.ixx" line="73" column="21" bodyfile="include/helios/math/transform/model.ixx" bodystart="73" bodyend="81"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1aca9266bbc6a927b4e082fb75d0d31434" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespacehelios_1_1math_1a27682cda52181a23edab8c0249fa531d" kindref="member">TransformType</ref></type>
        <definition>TransformType helios::math::operator|</definition>
        <argsstring>(TransformType a, TransformType b)</argsstring>
        <name>operator|</name>
        <qualifiedname>helios::math::operator|</qualifiedname>
        <param>
          <type><ref refid="namespacehelios_1_1math_1a27682cda52181a23edab8c0249fa531d" kindref="member">TransformType</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="namespacehelios_1_1math_1a27682cda52181a23edab8c0249fa531d" kindref="member">TransformType</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Combines two Inherit flags using bitwise OR. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>The first inheritance flag. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>The second inheritance flag.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The combined inheritance mask. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/TransformType.ixx" line="83" column="26" bodyfile="include/helios/math/TransformType.ixx" bodystart="83" bodyend="85"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a21fb88902bc365300cd88dad37e1d123" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool helios::math::transformTypeMatch</definition>
        <argsstring>(TransformType mask, TransformType flag)</argsstring>
        <name>transformTypeMatch</name>
        <qualifiedname>helios::math::transformTypeMatch</qualifiedname>
        <param>
          <type><ref refid="namespacehelios_1_1math_1a27682cda52181a23edab8c0249fa531d" kindref="member">TransformType</ref></type>
          <declname>mask</declname>
        </param>
        <param>
          <type><ref refid="namespacehelios_1_1math_1a27682cda52181a23edab8c0249fa531d" kindref="member">TransformType</ref></type>
          <declname>flag</declname>
        </param>
        <briefdescription>
<para>Checks if a specific inheritance flag is set in a mask. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>The inheritance mask to check against. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flag</parametername>
</parameternamelist>
<parameterdescription>
<para>The specific flag to test for.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>`true` if the flag is present in the mask, `false` otherwise.</para>
</simplesect>
Example usage: ```cpp using namespace <ref refid="namespacehelios_1_1math" kindref="compound">helios::math</ref>;</para>
<para><ref refid="namespacehelios_1_1math_1a27682cda52181a23edab8c0249fa531d" kindref="member">TransformType</ref> mode = <ref refid="namespacehelios_1_1math_1a27682cda52181a23edab8c0249fa531da6dd08874f83507e9c7b23f1a46b7fa7c" kindref="member">TransformType::Translation</ref> | <ref refid="namespacehelios_1_1math_1a27682cda52181a23edab8c0249fa531daf1a42bd417390fc63b030a519624607a" kindref="member">TransformType::Rotation</ref>;</para>
<para>if (transformTypeMatch(mode, TransformType::Translation)) { // Apply parent translation... } ``` </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/TransformType.ixx" line="107" column="17" bodyfile="include/helios/math/TransformType.ixx" bodystart="107" bodyend="109"/>
        <referencedby refid="structhelios_1_1math_1_1mat4_1a9c19cb795b7d8a032dd4cb415803f163" compoundref="mat4_8ixx" startline="313" endline="357">helios::math::mat4&lt; float &gt;::decompose</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a0e37b93487d103aa6588ba44bdb1a0b6" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>const T *</type>
        <definition>const T * helios::math::value_ptr</definition>
        <argsstring>(const mat4&lt; T &gt; &amp;m) noexcept</argsstring>
        <name>value_ptr</name>
        <qualifiedname>helios::math::value_ptr</qualifiedname>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1mat4" kindref="compound">mat4</ref>&lt; T &gt; &amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Returns a const pointer to the first element of the matrix&apos;s components. </para>
        </briefdescription>
        <detaileddescription>
<para>Useful for APIs that expect a pointer to matrix data, like OpenGL.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the matrix components.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>A reference to the `mat4&lt;T&gt;` matrix.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A const pointer to the element at [0, 0]. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/mat4.ixx" line="374" column="13" bodyfile="include/helios/math/types/mat4.ixx" bodystart="374" bodyend="376"/>
        <referencedby refid="structhelios_1_1math_1_1mat4_1a33c47f9920f5e88b98caca96a889d0aa" compoundref="mat4_8ixx" startline="206" endline="218">helios::math::mat4&lt; float &gt;::operator==</referencedby>
        <referencedby refid="structhelios_1_1math_1_1mat4_1a11484773381edf083309360d6c940d3f" compoundref="mat4_8ixx" startline="181" endline="195">helios::math::mat4&lt; float &gt;::same</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a581fd38f8554d49c33a42b46255cc983" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T * helios::math::value_ptr</definition>
        <argsstring>(mat4&lt; T &gt; &amp;m) noexcept</argsstring>
        <name>value_ptr</name>
        <qualifiedname>helios::math::value_ptr</qualifiedname>
        <param>
          <type><ref refid="structhelios_1_1math_1_1mat4" kindref="compound">mat4</ref>&lt; T &gt; &amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Returns a pointer to the first element of the matrix&apos;s components. </para>
        </briefdescription>
        <detaileddescription>
<para>Useful for APIs that expect a pointer to matrix data, like OpenGL.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the matrix components.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>A reference to the `mat4&lt;T&gt;` matrix.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A pointer to the element at [0, 0]. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/mat4.ixx" line="391" column="7" bodyfile="include/helios/math/types/mat4.ixx" bodystart="391" bodyend="393"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a3aa0fd063dbb05fb49b6e82621fedfed" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type><ref refid="structhelios_1_1math_1_1vec2" kindref="compound">vec2</ref>&lt; T &gt;</type>
        <definition>vec2&lt; T &gt; helios::math::operator*</definition>
        <argsstring>(const vec2&lt; T &gt; &amp;v, const T n) noexcept</argsstring>
        <name>operator*</name>
        <qualifiedname>helios::math::operator*</qualifiedname>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec2" kindref="compound">vec2</ref>&lt; T &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>const T</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Multiplies a 2D vector by a scalar value. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the vector components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="structhelios_1_1math_1_1vec2" kindref="compound">vec2&lt;T&gt;</ref> vector to be multiplied. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>The scalar vector to multiplay the vector by.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a new <ref refid="structhelios_1_1math_1_1vec2" kindref="compound">vec2&lt;T&gt;</ref> instance representing the result of the scalar multiplication. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec2.ixx" line="173" column="20" bodyfile="include/helios/math/types/vec2.ixx" bodystart="173" bodyend="175"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a7523e1a120cccd29674cf428bfdeb86c" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T helios::math::dot</definition>
        <argsstring>(const vec2&lt; T &gt; &amp;v1, const vec2&lt; T &gt; &amp;v2) noexcept</argsstring>
        <name>dot</name>
        <qualifiedname>helios::math::dot</qualifiedname>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec2" kindref="compound">vec2</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec2" kindref="compound">vec2</ref>&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the dot product of two 2D vectors. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the vector components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>The first <ref refid="structhelios_1_1math_1_1vec2" kindref="compound">vec2&lt;T&gt;</ref> vector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>The second <ref refid="structhelios_1_1math_1_1vec2" kindref="compound">vec2&lt;T&gt;</ref> vector.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The dot product as a value of type T. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec2.ixx" line="188" column="17" bodyfile="include/helios/math/types/vec2.ixx" bodystart="188" bodyend="190"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1ae21f80815ae495b8d521d6ad829ee7b6" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type><ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt;</type>
        <definition>vec3&lt; T &gt; helios::math::operator*</definition>
        <argsstring>(const vec3&lt; T &gt; &amp;v, const T n) noexcept</argsstring>
        <name>operator*</name>
        <qualifiedname>helios::math::operator*</qualifiedname>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>const T</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Multiplies a 3D vector by a scalar value. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the vector components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector to be multiplied. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>The scalar value to multiply the vector by.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a new <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> instance representing the result of the scalar multiplication. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="213" column="20" bodyfile="include/helios/math/types/vec3.ixx" bodystart="213" bodyend="215"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1accf7fb22d70fc125b56f230c6c6cc8d5" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type><ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt;</type>
        <definition>vec3&lt; T &gt; helios::math::operator/</definition>
        <argsstring>(const vec3&lt; T &gt; &amp;v, T s) noexcept</argsstring>
        <name>operator/</name>
        <qualifiedname>helios::math::operator/</qualifiedname>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>T</type>
          <declname>s</declname>
        </param>
        <briefdescription>
<para>Divides a 3D vector by a scalar value. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the vector components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector to be divided. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>The scalar divisor. Must not be zero.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A new <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> instance representing the result of the scalar division.</para>
</simplesect>
<simplesect kind="pre"><para>s != 0 (asserted in debug builds). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="229" column="20" bodyfile="include/helios/math/types/vec3.ixx" bodystart="229" bodyend="233"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a81d43c532316a12782bef5db9230ff84" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type><ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt;</type>
        <definition>vec3&lt; T &gt; helios::math::operator*</definition>
        <argsstring>(const T n, const vec3&lt; T &gt; &amp;v) noexcept</argsstring>
        <name>operator*</name>
        <qualifiedname>helios::math::operator*</qualifiedname>
        <param>
          <type>const T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Multiplies a scalar value by a 3D vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the vector components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>The scalar value to multiply the vector by. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector to be multiplied.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A new <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> instance representing the result of the scalar multiplication. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="246" column="20" bodyfile="include/helios/math/types/vec3.ixx" bodystart="246" bodyend="248"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a6bca908e940499722f0a3af6447ad719" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type><ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt;</type>
        <definition>vec3&lt; T &gt; helios::math::operator*</definition>
        <argsstring>(const vec3&lt; T &gt; &amp;v1, const vec3&lt; T &gt; &amp;v2) noexcept</argsstring>
        <name>operator*</name>
        <qualifiedname>helios::math::operator*</qualifiedname>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Multiplies two vectors componentwise. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the vector components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>The left-hand <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector to be multiplied. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>The right-hand <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector to be multiplied.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A new <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> instance representing the result of the componentwise multiplication of the two vectors. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="261" column="20" bodyfile="include/helios/math/types/vec3.ixx" bodystart="261" bodyend="263"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a01625d8968c400bd7e812715d7f1941f" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type><ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt;</type>
        <definition>vec3&lt; T &gt; helios::math::operator+</definition>
        <argsstring>(const vec3&lt; T &gt; &amp;v1, const vec3&lt; T &gt; &amp;v2) noexcept</argsstring>
        <name>operator+</name>
        <qualifiedname>helios::math::operator+</qualifiedname>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Calculates the componentwise sum of the two vectors. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the vector components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>The left-hand <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector to be added. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>The right-hand <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector to be added.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A new <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> instance representing the sum of the two vectors. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="276" column="20" bodyfile="include/helios/math/types/vec3.ixx" bodystart="276" bodyend="278"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a82d2ab8d8240be4606a885c554b93fb5" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type><ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt;</type>
        <definition>vec3&lt; T &gt; helios::math::cross</definition>
        <argsstring>(const vec3&lt; T &gt; &amp;v1, const vec3&lt; T &gt; &amp;v2) noexcept</argsstring>
        <name>cross</name>
        <qualifiedname>helios::math::cross</qualifiedname>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the cross product of two 3D vectors. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the vector components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>The first <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>The second <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A new <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> instance representing the cross product. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="291" column="20" bodyfile="include/helios/math/types/vec3.ixx" bodystart="291" bodyend="297"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a076c3e1ea3dd5beb87bc701e87cd4f1a" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T helios::math::dot</definition>
        <argsstring>(const vec3&lt; T &gt; &amp;v1, const vec3&lt; T &gt; &amp;v2) noexcept</argsstring>
        <name>dot</name>
        <qualifiedname>helios::math::dot</qualifiedname>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the dot product of two 3D vectors. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the vector components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>The first <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>The second <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The dot product as a value of type T. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="310" column="17" bodyfile="include/helios/math/types/vec3.ixx" bodystart="310" bodyend="312"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a7a21ef269927b19863a1eae2d87666ee" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type><ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt;</type>
        <definition>vec3&lt; T &gt; helios::math::operator-</definition>
        <argsstring>(const vec3&lt; T &gt; &amp;v1, const vec3&lt; T &gt; &amp;v2) noexcept</argsstring>
        <name>operator-</name>
        <qualifiedname>helios::math::operator-</qualifiedname>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the difference between two vectors (vector subtraction). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the vector components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>The first <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>The second <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A new <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> instance representing the difference between v1 and v2. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="325" column="20" bodyfile="include/helios/math/types/vec3.ixx" bodystart="325" bodyend="327"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1afba89a2aa6938d85fd8be3974a9aed36" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>const T *</type>
        <definition>const T * helios::math::value_ptr</definition>
        <argsstring>(const vec4&lt; T &gt; &amp;m) noexcept</argsstring>
        <name>value_ptr</name>
        <qualifiedname>helios::math::value_ptr</qualifiedname>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec4" kindref="compound">vec4</ref>&lt; T &gt; &amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Returns a const pointer to the first element of the vector&apos;s components. </para>
        </briefdescription>
        <detaileddescription>
<para>Useful for APIs that expect a pointer to vector data, like OpenGL <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>A reference to the `vec4&lt;T&gt;` vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the vector components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec4.ixx" line="129" column="13" bodyfile="include/helios/math/types/vec4.ixx" bodystart="129" bodyend="131"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a4949642a7cca09c7950bb6a1b75260c9" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>float</type>
        <definition>float helios::math::radians</definition>
        <argsstring>(const float angle) noexcept</argsstring>
        <name>radians</name>
        <qualifiedname>helios::math::radians</qualifiedname>
        <param>
          <type>const float</type>
          <declname>angle</declname>
        </param>
        <briefdescription>
<para>Converts an angle from degrees to radians. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>angle</parametername>
</parameternamelist>
<parameterdescription>
<para>The angle value in degrees. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The converted angle value in radians. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/utils.ixx" line="30" column="21" bodyfile="include/helios/math/utils.ixx" bodystart="30" bodyend="32"/>
        <referencedby refid="namespacehelios_1_1math_1a73c58ac1ac41973b9927ab6893662104" compoundref="utils_8ixx" startline="40" endline="42">degrees</referencedby>
        <referencedby refid="classhelios_1_1ext_1_1imgui_1_1widgets_1_1CameraWidget_1a07fc0fbbf52e97d447e2f3177980dd00" compoundref="CameraWidget_8ixx" startline="213" endline="424">helios::ext::imgui::widgets::CameraWidget::draw</referencedby>
        <referencedby refid="namespacehelios_1_1math_1a643691235959c2f53d144a4ee9a0e251">rotate</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a73c58ac1ac41973b9927ab6893662104" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>float</type>
        <definition>float helios::math::degrees</definition>
        <argsstring>(const float radians) noexcept</argsstring>
        <name>degrees</name>
        <qualifiedname>helios::math::degrees</qualifiedname>
        <param>
          <type>const float</type>
          <declname>radians</declname>
        </param>
        <briefdescription>
<para>Converts an angle from radians to degrees. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>radians</parametername>
</parameternamelist>
<parameterdescription>
<para>The angle value in radians. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The converted angle value in degrees. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/utils.ixx" line="40" column="21" bodyfile="include/helios/math/utils.ixx" bodystart="40" bodyend="42"/>
        <references refid="namespacehelios_1_1math_1a4949642a7cca09c7950bb6a1b75260c9" compoundref="utils_8ixx" startline="30" endline="32">radians</references>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>Mathematical operations and types. </para>
    </briefdescription>
    <detaileddescription>
<para>This namespace provides comprehensive mathematical functionality including vector and matrix types, transformation utilities, mathematical concepts, and utility functions for 3D graphics and game framework computations. Provides all mathematical operations required for 3D graphics, including transformations, projections, and spatial computations. </para>
    </detaileddescription>
    <location file="include/helios/math/concepts/Numeric.ixx" line="7" column="1"/>
  </compounddef>
</doxygen>
