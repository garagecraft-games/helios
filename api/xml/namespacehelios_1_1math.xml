<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="namespacehelios_1_1math" kind="namespace" language="C++">
    <compoundname>helios::math</compoundname>
    <innerclass refid="structhelios_1_1math_1_1mat4" prot="public">helios::math::mat4</innerclass>
    <innerclass refid="structhelios_1_1math_1_1vec2" prot="public">helios::math::vec2</innerclass>
    <innerclass refid="structhelios_1_1math_1_1vec3" prot="public">helios::math::vec3</innerclass>
    <innerclass refid="structhelios_1_1math_1_1vec4" prot="public">helios::math::vec4</innerclass>
    <innerconcept refid="concepthelios_1_1math_1_1Numeric">helios::math::Numeric</innerconcept>
    <innernamespace refid="namespacehelios_1_1math_1_1concepts">helios::math::concepts</innernamespace>
    <innernamespace refid="namespacehelios_1_1math_1_1transform">helios::math::transform</innernamespace>
    <innernamespace refid="namespacehelios_1_1math_1_1types">helios::math::types</innernamespace>
    <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1mat4" kindref="compound">mat4</ref>&lt; float &gt;</type>
        <definition>using helios::math::mat4f =  mat4&lt;float&gt;</definition>
        <argsstring></argsstring>
        <name>mat4f</name>
        <qualifiedname>helios::math::mat4f</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/mat4.ixx" line="249" column="5" bodyfile="include/helios/math/types/mat4.ixx" bodystart="249" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1a058bd8629e8b9fdd7914ec513cf515f5" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1mat4" kindref="compound">mat4</ref>&lt; double &gt;</type>
        <definition>using helios::math::mat4d =  mat4&lt;double&gt;</definition>
        <argsstring></argsstring>
        <name>mat4d</name>
        <qualifiedname>helios::math::mat4d</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/mat4.ixx" line="250" column="5" bodyfile="include/helios/math/types/mat4.ixx" bodystart="250" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1abfde83491c8def2cca7e8816bb9a0075" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1mat4" kindref="compound">mat4</ref>&lt; int &gt;</type>
        <definition>using helios::math::mat4i =  mat4&lt;int&gt;</definition>
        <argsstring></argsstring>
        <name>mat4i</name>
        <qualifiedname>helios::math::mat4i</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/mat4.ixx" line="251" column="5" bodyfile="include/helios/math/types/mat4.ixx" bodystart="251" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1aeab5c7e555a142f8f763a3317460d5c0" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1vec2" kindref="compound">vec2</ref>&lt; float &gt;</type>
        <definition>using helios::math::vec2f =  vec2&lt;float&gt;</definition>
        <argsstring></argsstring>
        <name>vec2f</name>
        <qualifiedname>helios::math::vec2f</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec2.ixx" line="94" column="5" bodyfile="include/helios/math/types/vec2.ixx" bodystart="94" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1acb8f1b0c5acc937254f38e27787db452" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1vec2" kindref="compound">vec2</ref>&lt; double &gt;</type>
        <definition>using helios::math::vec2d =  vec2&lt;double&gt;</definition>
        <argsstring></argsstring>
        <name>vec2d</name>
        <qualifiedname>helios::math::vec2d</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec2.ixx" line="95" column="5" bodyfile="include/helios/math/types/vec2.ixx" bodystart="95" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1aff32bafe25abeda0bb858b51ae46bff8" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1vec2" kindref="compound">vec2</ref>&lt; int &gt;</type>
        <definition>using helios::math::vec2i =  vec2&lt;int&gt;</definition>
        <argsstring></argsstring>
        <name>vec2i</name>
        <qualifiedname>helios::math::vec2i</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec2.ixx" line="96" column="5" bodyfile="include/helios/math/types/vec2.ixx" bodystart="96" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1a71f1e40e636f47229c3122bdb63099d5" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; float &gt;</type>
        <definition>using helios::math::vec3f =  vec3&lt;float&gt;</definition>
        <argsstring></argsstring>
        <name>vec3f</name>
        <qualifiedname>helios::math::vec3f</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="209" column="5" bodyfile="include/helios/math/types/vec3.ixx" bodystart="209" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1a0fd329cdb93d866fad284b88f7acb4f4" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; int &gt;</type>
        <definition>using helios::math::vec3i =  vec3&lt;int&gt;</definition>
        <argsstring></argsstring>
        <name>vec3i</name>
        <qualifiedname>helios::math::vec3i</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="210" column="5" bodyfile="include/helios/math/types/vec3.ixx" bodystart="210" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1a57c950d4cb887c103dc2423f3ea81ce4" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; double &gt;</type>
        <definition>using helios::math::vec3d =  vec3&lt;double&gt;</definition>
        <argsstring></argsstring>
        <name>vec3d</name>
        <qualifiedname>helios::math::vec3d</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="211" column="5" bodyfile="include/helios/math/types/vec3.ixx" bodystart="211" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1a08252f81850c5902e3c8dead272f3332" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1vec4" kindref="compound">vec4</ref>&lt; float &gt;</type>
        <definition>using helios::math::vec4f =  vec4&lt;float&gt;</definition>
        <argsstring></argsstring>
        <name>vec4f</name>
        <qualifiedname>helios::math::vec4f</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec4.ixx" line="116" column="5" bodyfile="include/helios/math/types/vec4.ixx" bodystart="116" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1a78a0f495523b71681b549f098f994126" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1vec4" kindref="compound">vec4</ref>&lt; double &gt;</type>
        <definition>using helios::math::vec4d =  vec4&lt;double&gt;</definition>
        <argsstring></argsstring>
        <name>vec4d</name>
        <qualifiedname>helios::math::vec4d</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec4.ixx" line="117" column="5" bodyfile="include/helios/math/types/vec4.ixx" bodystart="117" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacehelios_1_1math_1a9ce6ecf5869b53d92a26354e2c48d0b4" prot="public" static="no">
        <type><ref refid="structhelios_1_1math_1_1vec4" kindref="compound">vec4</ref>&lt; int &gt;</type>
        <definition>using helios::math::vec4i =  vec4&lt;int&gt;</definition>
        <argsstring></argsstring>
        <name>vec4i</name>
        <qualifiedname>helios::math::vec4i</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec4.ixx" line="118" column="5" bodyfile="include/helios/math/types/vec4.ixx" bodystart="118" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="namespacehelios_1_1math_1aef6bef7ca3d31a4908a66e16c9771420" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref></type>
        <definition>mat4f helios::math::lookAt</definition>
        <argsstring>(const vec3f &amp;eye, const vec3f &amp;center, const vec3f &amp;up) noexcept</argsstring>
        <name>lookAt</name>
        <qualifiedname>helios::math::lookAt</qualifiedname>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1a71f1e40e636f47229c3122bdb63099d5" kindref="member">vec3f</ref> &amp;</type>
          <declname>eye</declname>
        </param>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1a71f1e40e636f47229c3122bdb63099d5" kindref="member">vec3f</ref> &amp;</type>
          <declname>center</declname>
        </param>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1a71f1e40e636f47229c3122bdb63099d5" kindref="member">vec3f</ref> &amp;</type>
          <declname>up</declname>
        </param>
        <briefdescription>
<para>Returns the 4x4 lookAt-matrix for transforming world coordinates to camera space. The method creates the camera coordinate system based on the parameters eye, i.e. the vantage point in world space, the camera&apos;s up direction and center, representing the point of interest. Note that the returned matrix is essentially a composition of a change of coordinates matrix P(C &lt;- W) and a translation to the origin, i.e. the camera is sitting at the origin (0, 0, 0) looking down the negative z-axis, i.e. conceptually. </para>
        </briefdescription>
        <detaileddescription>
<para>P(W&lt;-C) * T(-eye)</para>
<para>The 4x4 matrix can then be used for computing the perspective projection for creating the clip space</para>
<para>clip = P * V * W * M</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>eye</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>center</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>up</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/transform/camera.ixx" line="33" column="11" declfile="include/helios/math/transform/camera.ixx" declline="33" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a643691235959c2f53d144a4ee9a0e251" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref></type>
        <definition>mat4f helios::math::rotate</definition>
        <argsstring>(const mat4f &amp;model, float radians, const vec3f &amp;axis) noexcept</argsstring>
        <name>rotate</name>
        <qualifiedname>helios::math::rotate</qualifiedname>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>float</type>
          <declname>radians</declname>
        </param>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1a71f1e40e636f47229c3122bdb63099d5" kindref="member">vec3f</ref> &amp;</type>
          <declname>axis</declname>
        </param>
        <briefdescription>
<para>Creates an affine rotation matrix R&apos; = M * R by &quot;baking&quot; the rotation part into the model matrix. Any operation R&apos; * v will make sure that v is rotated around the local origin, then transformed into world space. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>model</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>radians</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>axis</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/transform/model.ixx" line="19" column="11" declfile="include/helios/math/transform/model.ixx" declline="19" declcolumn="11"/>
        <references refid="namespacehelios_1_1math_1a4949642a7cca09c7950bb6a1b75260c9" compoundref="utils_8ixx" startline="18" endline="20">radians</references>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1addafb8dbe33d09352658b55cee9a0898" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref></type>
        <definition>mat4f helios::math::translate</definition>
        <argsstring>(const mat4f &amp;model, const vec3f &amp;v) noexcept</argsstring>
        <name>translate</name>
        <qualifiedname>helios::math::translate</qualifiedname>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1a71f1e40e636f47229c3122bdb63099d5" kindref="member">vec3f</ref> &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Creates an affine transformation matrix M&apos; = M * T by &quot;baking&quot; the translation part into the model matrix. Any operation M&apos; * v will make sure that v is translated in local space, then transformed into world space. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>model</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/transform/model.ixx" line="31" column="22" bodyfile="include/helios/math/transform/model.ixx" bodystart="31" bodyend="37"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1ae230dbf0f416c8c868d5fea73d6babdb" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref></type>
        <definition>mat4f helios::math::scale</definition>
        <argsstring>(const mat4f &amp;model, const vec3f &amp;v) noexcept</argsstring>
        <name>scale</name>
        <qualifiedname>helios::math::scale</qualifiedname>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1a71f1e40e636f47229c3122bdb63099d5" kindref="member">vec3f</ref> &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Creates an affine transformation matrix S&apos; = M * S by &quot;&quot;baking" the scaling part into the model matrix. Any operation S&apos; * v will make sure that v is scaled in local space, then transformed into world space. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>model</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/transform/model.ixx" line="49" column="21" bodyfile="include/helios/math/transform/model.ixx" bodystart="49" bodyend="57"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a8cc238c96b9b131d26357870e87ed668" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref></type>
        <definition>mat4f helios::math::scale</definition>
        <argsstring>(const mat4f &amp;model, const float scale_by) noexcept</argsstring>
        <name>scale</name>
        <qualifiedname>helios::math::scale</qualifiedname>
        <param>
          <type>const <ref refid="namespacehelios_1_1math_1ad422120d6e1f106140808f16e348f0b3" kindref="member">mat4f</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const float</type>
          <declname>scale_by</declname>
        </param>
        <briefdescription>
<para>Creates an affine transformation matrix S&apos; = M * S by &quot;baking&quot; the scaling part into the model matrix. Any operation S&apos; * v will make sure that v is scaled in local space, then transformed into world space. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>model</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scale_by</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/transform/model.ixx" line="69" column="21" bodyfile="include/helios/math/transform/model.ixx" bodystart="69" bodyend="77"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a0e37b93487d103aa6588ba44bdb1a0b6" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>const T *</type>
        <definition>const T * helios::math::value_ptr</definition>
        <argsstring>(const mat4&lt; T &gt; &amp;m) noexcept</argsstring>
        <name>value_ptr</name>
        <qualifiedname>helios::math::value_ptr</qualifiedname>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1mat4" kindref="compound">mat4</ref>&lt; T &gt; &amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Returns a const pointer to the first element of the matrix&apos;s components. </para>
        </briefdescription>
        <detaileddescription>
<para>Useful for APIs that expect a pointer to matrix data, like OpenGL.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the matrix components.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>A reference to the `mat4&lt;T&gt;` matrix.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A const pointer to the element at [0, 0]. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/mat4.ixx" line="228" column="13" bodyfile="include/helios/math/types/mat4.ixx" bodystart="228" bodyend="230"/>
        <referencedby refid="structhelios_1_1math_1_1mat4_1a33c47f9920f5e88b98caca96a889d0aa" compoundref="mat4_8ixx" startline="175" endline="187">helios::math::mat4&lt; float &gt;::operator==</referencedby>
        <referencedby refid="structhelios_1_1math_1_1mat4_1a11484773381edf083309360d6c940d3f" compoundref="mat4_8ixx" startline="150" endline="164">helios::math::mat4&lt; float &gt;::same</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a581fd38f8554d49c33a42b46255cc983" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T * helios::math::value_ptr</definition>
        <argsstring>(mat4&lt; T &gt; &amp;m) noexcept</argsstring>
        <name>value_ptr</name>
        <qualifiedname>helios::math::value_ptr</qualifiedname>
        <param>
          <type><ref refid="structhelios_1_1math_1_1mat4" kindref="compound">mat4</ref>&lt; T &gt; &amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Returns a pointer to the first element of the matrix&apos;s components. </para>
        </briefdescription>
        <detaileddescription>
<para>Useful for APIs that expect a pointer to matrix data, like OpenGL.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the matrix components.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>A reference to the `mat4&lt;T&gt;` matrix.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A pointer to the element at [0, 0]. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/mat4.ixx" line="245" column="7" bodyfile="include/helios/math/types/mat4.ixx" bodystart="245" bodyend="247"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a7523e1a120cccd29674cf428bfdeb86c" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T helios::math::dot</definition>
        <argsstring>(const vec2&lt; T &gt; &amp;v1, const vec2&lt; T &gt; &amp;v2) noexcept</argsstring>
        <name>dot</name>
        <qualifiedname>helios::math::dot</qualifiedname>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec2" kindref="compound">vec2</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec2" kindref="compound">vec2</ref>&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the dot product of two 2D vectors. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the vector components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>The first <ref refid="structhelios_1_1math_1_1vec2" kindref="compound">vec2&lt;T&gt;</ref> vector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>The second <ref refid="structhelios_1_1math_1_1vec2" kindref="compound">vec2&lt;T&gt;</ref> vector.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The dot product as a value of type T. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec2.ixx" line="90" column="17" bodyfile="include/helios/math/types/vec2.ixx" bodystart="90" bodyend="92"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1ae21f80815ae495b8d521d6ad829ee7b6" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type><ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt;</type>
        <definition>vec3&lt; T &gt; helios::math::operator*</definition>
        <argsstring>(const vec3&lt; T &gt; &amp;v, const T n) noexcept</argsstring>
        <name>operator*</name>
        <qualifiedname>helios::math::operator*</qualifiedname>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>const T</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Multiplies a 3D vector by a scalar value. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the vector components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector to be multiplied. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>The scalar vector to multiplay the vector by.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a new <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> instance representing the result of the scalar multiplication. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="128" column="20" bodyfile="include/helios/math/types/vec3.ixx" bodystart="128" bodyend="130"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a81d43c532316a12782bef5db9230ff84" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type><ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt;</type>
        <definition>vec3&lt; T &gt; helios::math::operator*</definition>
        <argsstring>(const T n, const vec3&lt; T &gt; &amp;v) noexcept</argsstring>
        <name>operator*</name>
        <qualifiedname>helios::math::operator*</qualifiedname>
        <param>
          <type>const T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Multiplies a scalar value by a 3D vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the vector components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>The scalar value to multiply the vector by. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector to be multiplied.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A new <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> instance representing the result of the scalar multiplication. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="144" column="20" bodyfile="include/helios/math/types/vec3.ixx" bodystart="144" bodyend="146"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a82d2ab8d8240be4606a885c554b93fb5" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type><ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt;</type>
        <definition>vec3&lt; T &gt; helios::math::cross</definition>
        <argsstring>(const vec3&lt; T &gt; &amp;v1, const vec3&lt; T &gt; &amp;v2) noexcept</argsstring>
        <name>cross</name>
        <qualifiedname>helios::math::cross</qualifiedname>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the cross product of two 3D vectors. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the vector components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>The first <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>The second <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A new <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> instance representing the cross product. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="170" column="20" bodyfile="include/helios/math/types/vec3.ixx" bodystart="170" bodyend="176"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a076c3e1ea3dd5beb87bc701e87cd4f1a" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T helios::math::dot</definition>
        <argsstring>(const vec3&lt; T &gt; &amp;v1, const vec3&lt; T &gt; &amp;v2) noexcept</argsstring>
        <name>dot</name>
        <qualifiedname>helios::math::dot</qualifiedname>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the dot product of two 3D vectors. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the vector components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>The first <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>The second <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The dot product as a value of type T. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="189" column="17" bodyfile="include/helios/math/types/vec3.ixx" bodystart="189" bodyend="191"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a7a21ef269927b19863a1eae2d87666ee" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type><ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt;</type>
        <definition>vec3&lt; T &gt; helios::math::operator-</definition>
        <argsstring>(const vec3&lt; T &gt; &amp;v1, const vec3&lt; T &gt; &amp;v2) noexcept</argsstring>
        <name>operator-</name>
        <qualifiedname>helios::math::operator-</qualifiedname>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3</ref>&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the difference between two vectors (vector subtraction). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the vector components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>The first <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>The second <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> vector.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A new <ref refid="structhelios_1_1math_1_1vec3" kindref="compound">vec3&lt;T&gt;</ref> instance representing the difference between v1 and v2. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec3.ixx" line="204" column="20" bodyfile="include/helios/math/types/vec3.ixx" bodystart="204" bodyend="206"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1afba89a2aa6938d85fd8be3974a9aed36" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="concepthelios_1_1math_1_1Numeric" kindref="compound">helios::math::Numeric</ref></type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>const T *</type>
        <definition>const T * helios::math::value_ptr</definition>
        <argsstring>(const vec4&lt; T &gt; &amp;m) noexcept</argsstring>
        <name>value_ptr</name>
        <qualifiedname>helios::math::value_ptr</qualifiedname>
        <param>
          <type>const <ref refid="structhelios_1_1math_1_1vec4" kindref="compound">vec4</ref>&lt; T &gt; &amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Returns a const pointer to the first element of the vector&apos;s components. </para>
        </briefdescription>
        <detaileddescription>
<para>Useful for APIs that expect a pointer to vector data, like OpenGL.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The numeric type of the vector components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>A reference to the `vec4&lt;T&gt;` vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A const pointer to the element at index 0. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/types/vec4.ixx" line="112" column="13" bodyfile="include/helios/math/types/vec4.ixx" bodystart="112" bodyend="114"/>
      </memberdef>
      <memberdef kind="function" id="namespacehelios_1_1math_1a4949642a7cca09c7950bb6a1b75260c9" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>float</type>
        <definition>float helios::math::radians</definition>
        <argsstring>(const float angle) noexcept</argsstring>
        <name>radians</name>
        <qualifiedname>helios::math::radians</qualifiedname>
        <param>
          <type>const float</type>
          <declname>angle</declname>
        </param>
        <briefdescription>
<para>Converts an angle from degrees to radians. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>angle</parametername>
</parameternamelist>
<parameterdescription>
<para>The angle value in degrees. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The converted angle value in radians. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/helios/math/utils.ixx" line="18" column="21" bodyfile="include/helios/math/utils.ixx" bodystart="18" bodyend="20"/>
        <referencedby refid="namespacehelios_1_1math_1a643691235959c2f53d144a4ee9a0e251">rotate</referencedby>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>Mathematical operations and types. </para>
    </briefdescription>
    <detaileddescription>
<para>This namespace provides comprehensive mathematical functionality including vector and matrix types, transformation utilities, mathematical concepts, and utility functions for 3D graphics and game framework computations. Provides all mathematical operations required for 3D graphics, including transformations, projections, and spatial computations. </para>
    </detaileddescription>
    <location file="include/helios/math/concepts/Numeric.ixx" line="7" column="1"/>
  </compounddef>
</doxygen>
